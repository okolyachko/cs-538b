<html>
<head>
<title>Course transcript</title>
</head>
<body>
<p>
	All right, folks.
	Let's get started.
	Anybody have any notes?
	I do not.
	I think everything's going well from my side.
	Anything on your side that's not going well?
	All right.
	Things are going well.
	Interesting, like, news item for the day.
	This is a graph representing the amount of time it takes to run a linter on the CPython
	codebase from scratch.
	The top line is a service called Ruff.
	Down below, autoflake, flake8, pyflakes, pycode-style, pylint.
	For those of you who don't know, a linter is something that goes through a codebase
	or it parses code to find idiosyncratic usages of the language.
	So it will alert you in JavaScript if you have forgotten your semicolon.
	And it suggests maybe you want a semicolon.
	Even though it's not needed, it's purely a cosmetic improvement.
	But somebody's got to do it.
	So Ruff is a new service that does this.
	And it does it in .3 seconds, compared to the next fastest in 6 seconds.
	Which is 20 times faster than the next fastest competitor.
	The only difference between the first one and the bottom five...
	The first one is written in Rust.
	The bottom five are all written in Python.
	They implement the same features.
	They're doing the exact same thing.
	The people who wrote these bottom five weren't dumb.
	They're often the maintainers of Python.
	They're very intelligent people.
	But if you write it in Rust, it'll be 20 times faster.
	Kind of interesting.
	All right.
	Let's do an activity.
	Because I like activities.
	You guys can see this.
	Can everybody read this code?
	Is that big enough for everyone in the back?
	Cool.
	All right.
	This is from the midterm.
	This is the assignment.
	This is a problem that I gave on the midterm last semester.
	I asked the students from last semester to tell me what the output of running this program
	is.
	So I think let's start class by trying to solve that.
	And hopefully what we'll find is it's a little tricky to solve with our current knowledge.
	But through today's lecture, we'll develop some tools to help us solve it more consistently.
	So my task for you is chatting with two or three people around you.
	Try and figure out what is printed on line 14 to console.
	You can use scratch notes or any paper that you want.
	But try and figure it out.
	What's the output of the last line?
	If you can do it all in your head, great.
	That's fine.
	You don't need to.
	Because computers don't.
	So all right.
	Chat with people next to you.
	Figure out what it is.
	All right.
	All right.
	What do you guys think it is?
	35?
	25?
	You got an idea?
	Still working through it?
	What are you thinking so far?
	20 does become the Y.
	Okay.
	Why would it?
	Or why wouldn't it?
	Uh-huh.
	I think it does.
	Okay.
	Yeah.
	I like the idea that it does.
	Yeah.
	And then what's G?
	I'll let you keep working through it.
	It sounds like you're on the right path, though.
	How's it going over here?
	You guys have an idea?
	Nine.
	Nine?
	Why is?
	It's a closure problem, right?
	It is a closure problem.
	And is it related to F not being graphed as like another
	anomalous function?
	We give the other answer.
	What's the other answer?
	Right.
	Yeah.
	Yeah.
	Like, should A be updated or should it not?
	Yeah.
	Sounds like you guys have the right idea, though.
	So that's good.
	How's it going over here?
	Struggling?
	Well, what's the value of H?
	That's maybe where to start.
	You have an idea for what H is?
	Not quite.
	Okay.
	Yeah.
	So we're equal to calling F, right?
	We call F.
	And what is F?
	F is that, like, whole function, right?
	It's from line one all the way down to line 12.
	And so we want to figure out what's the result of running
	that function.
	So F is the big function.
	And so what is F returning?
	If we kind of ignore all the middle part of F,
	what's the last line say?
	We're, exactly, returning G.
	So H is going to be equal to whatever G is.
	And then we've got to go backwards and say, like,
	okay, well, what is G?
	But that's how I would start with this one.
	I'm assuming we're comparing the 20 input as Y.
	So I kind of understood that part.
	I'm just having a tough time seeing how to start.
	I think I've got a good idea.
	All right.
	All right.
	For sure.
	For sure.
	All right.
	Let's come back together.
	I heard a couple of different answers
	as I was wandering the room.
	Can I get some brave individuals to suggest
	what they think the result is?
	How many people feel like they came to a result, actually?
	Okay.
	Wow.
	Okay.
	Everybody.
	Or almost everybody.
	So what are some of the ideas?
	I'll write them down.
	I heard different ones.
	So we aren't all at the same place.
	Yeah.
	We have nine as an option.
	Anybody else?
	Nobody else has another idea for the answer?
	Everybody?
	Who votes nine?
	All right.
	All right.
	All right.
	So what you're saying is the midterm needs
	a little bit more of an interesting problem this year.
	No?
	Okay.
	So the answer is nine.
	How did we get there, though?
	Because this is 14 lines of weird obfuscated code
	where we kind of go in and then pop back out
	and then update the thing and come back.
	Yeah.
	Question?
	Oh.
	You have an answer for how we get there?
	I liked almost everything that you said
	except for the first line.
	Everything else, I'm with you on it,
	and we'll go over it explicitly.
	But yeah.
	Yeah.
	What's your question?
	That's exactly my question for your fellow student as well.
	Yeah.
	The thing that you said is that y is 20 because we're
	calling h of 20, h is f, so y gets the value 20.
	And that's not quite right.
	Who can change that?
	Yeah.
	Yeah.
	All right.
	This is the converse for you.
	I like exactly how you started.
	Didn't like quite where it went, though.
	But your first line, totally with you.
	Let's start, actually, with line 13
	and say h is equal to the result of f.
	Yeah.
	Exactly.
	So let's start here and say h is equal to the result
	of executing f.
	f is a function.
	It's going to return back something.
	Whatever it returns, h is going to store it.
	If we look at what f is returning,
	it's the line right here.
	We have to kind of scan through the whole function.
	f returns g.
	And indentation is your friend here.
	It's not guaranteed to be your friend.
	Braces are the real thing that you need to be looking at.
	But indentation kind of shows you the return g
	is the last return of f.
	It's the only return of f.
	So h is going to be equal to g.
	So when we execute h of 20, we can think of it
	as executing g of 20.
	But it's not only that h is equal to the code of g.
	It's also equal to the environment around g.
	And around g, we have this a equals 5.
	So we're going to call g of 20, where a is equal to 5.
	So 20 goes in for y.
	And this is, as one of you mentioned, 20 is equal to y.
	20 is greater than 10.
	a equals a minus 1.
	And this is where we're updating our environment
	for the function that we're calling.
	So we update a from being 5 to 4.
	Return g, where g is the code that we have,
	with the environment a is 4.
	Of 5, blah, blah, blah, blah, return 9.
	That's a lot to do in your head and to process.
	Computers are cheating, because they have all of this memory
	that they're keeping track of everything as it's going.
	We, as humans, don't have that.
	So how can we still look at this code
	and easily figure out what's going to happen
	and in what order?
	Some of you have already heard me say this many, many times
	in office hours.
	When does the code execute?
	When does this line of code or this expression execute?
	That's the key question you want to ask
	every time you're staring at JavaScript like this.
	When does this line of code execute?
	Not until we get to it.
	It doesn't happen when we parse line 9 or line 8.
	It happens when we've called h of 20,
	which then calls g of 5, which then returns y plus a.
	Being able to follow that is tricky.
	So let's make it easier.
	And this is where, at the end of the last lecture,
	we started bringing in this idea of a diagram
	to represent our environment.
	What do we want to keep track of in our environment?
	Whenever I call a function, what were we keeping track of?
	Or what do we want to keep track of?
	Yeah?
	The parameters.
	Definitely.
	So in our example over here, we have we're working
	with the factorial function.
	So we would have a parameter, n.
	What's the value of n?
	We're going to just start from the beginning.
	What's the value of n?
	Yeah.
	3.
	Yeah.
	Okay.
	What else do we want to keep track of?
	Yeah?
	Variables declared within the function.
	In this case, we don't have any.
	But, yes, we do.
	If we had said, like, let x equal 5,
	we would want to store x in our scope.
	What else?
	Recursive calls.
	What about them?
	What do we need to store?
	Yeah.
	And I think I want to generalize that to say,
	we care about what we are returning.
	So here, we're returning n times something.
	That's something.
	We could store it as kind of its own private variable.
	Or we could just call it the return value.
	So we have some return value that we will be storing.
	What else?
	What do I need to keep track of when I'm inside of a function
	for when I'm done?
	Other than the return value.
	We call that the control pointer.
	You also need to know where are you supposed to return to
	in code to continue execution.
	So, when we finish calling fact 3,
	jump back to this next line, whatever it is.
	That's also called the instruction pointer.
	In various assembly languages.
	Cool.
	So now we know what we came in with.
	What we are returning with.
	And where we return it to.
	And then if we had any more local state,
	we could store that here as well.
	This is similar to your stack frame.
	It's almost identical to your stack frame
	when you're thinking about stack frames in assembly or C.
	So, I've put those in here.
	And what I've represented is the return.
	I'm just calling ret.
	And then control, the control pointer.
	I'm saying return control back to global.
	Which just means return it back to where we were before.
	If we were nested deep inside of a recursive call,
	we would be pointing back to the start instead.
	Okay.
	So, to formalize some of these things,
	the control link records where we return the environment pointer to
	when we are done with our current scope.
	When we finish our current function, where do we return?
	Do we need that for block scopes?
	Yes?
	No.
	I don't know.
	I don't know is always a valid answer.
	Somebody who says yes, why?
	There were a few of you.
	Yeah?
	No, exactly.
	We wouldn't want to duplicate all of the information of the outside world into our block scope.
	So, let's treat a block scope as a completely almost identical to our function scope.
	And it will have a control pointer.
	It's always gonna be pretty obvious.
	You can kind of look.
	It's just directly back to where it came from.
	Whereas functions can be a little bit more complicated.
	But just because it's obvious doesn't mean we shouldn't do it.
	So, yeah.
	Okay.
	In terms of these other things,
	This is where the L value, R value comes in.
	Not the most important.
	Do we need anything else besides the control link?
	This is a bit of a trick question.
	Because I conflated these two.
	So, the control link specifically talks about the environment pointer.
	I'm also calling the control link the return address, where you are returning execution to.
	They're effectively one and the same.
	We talk more about returning to code addresses later, especially in a security context.
	So, we'll get to the fun stuff there in a future lecture.
	All the way at the end of class.
	Okay.
	So, let's actually do this.
	We start with fact 3.
	And when we call the function fact 3, we're going to immediately create an activation record.
	That looks like this.
	Where we say n is 3.
	Return we don't know yet.
	And control is going to global.
	When we're done, we come back to the global scope.
	What happens inside of fact 3?
	What do we do next?
	Yep.
	Which branch of the conditional do we take?
	We'll go into the else.
	Great.
	Return n times 3 times what?
	Yep.
	Factorial of 2.
	How do we figure out the result of factorial 2?
	We're going to create another activation record.
	And I've drawn this one a little big, but we can fit it in over here.
	What is going to be inside of our activation record?
	Yeah.
	n is 2.
	What else do we have?
	Yeah.
	Definitely.
	Yeah.
	So, control is going to point back to our first activation record.
	Which is saying, once we're done with this one, go back over here.
	Okay?
	And then what's the last thing that we have?
	As a class?
	Return.
	And what's the value?
	2 times what?
	Yet another activation record.
	What goes in this one?
	Someone knew.
	Yeah.
	n equals 1.
	What else?
	Yeah.
	Return 1.
	And where are we returning to?
	Yeah.
	Our CTL is going up to activation record number 2.
	Okay.
	So, we finished executing.
	We know what we are returning.
	Where do we go?
	Where do we go?
	Back to 2.
	We follow our control pointer to say, go back to 2.
	We were right in the middle of executing this return statement.
	So, it's 2 times 1.
	We've now finished this one.
	Where do we go from here?
	Back to the first one.
	Back to this one.
	And we know that we are returning the value 2.
	All right.
	Now we're done with this.
	Where do we go from here?
	Global.
	We'll go to global with the value 6.
	And we're going to return 6.
	This might feel very rote and mechanical.
	That is exactly by design.
	This is what the compiler or interpreter does.
	It needs to be mechanical.
	There's no creativity here.
	Because if there were, the computer couldn't do it.
	It's algorithmic for a reason.
	Because it's an algorithm.
	So, if it feels boring, I apologize.
	It'll make you a better coder.
	So, do it anyway.
	So, okay.
	We can put these up.
	At each point, as we are executing the activation record, we will update our environment pointer
	to say we're now executing this one.
	We're now executing this one.
	We're now executing this one.
	And then as we pop back up, we get to move our environment pointer to wherever our control
	pointer says.
	Okay.
	I've got a question for you here.
	Do we keep the activation records on the stack after evaluation?
	Once we have finished returning from this activation record, do we keep it on the stack?
	Or do we pop it off?
	Chat with your neighbor.
	Try and convince them of your opinion.
	What do you guys think?
	No?
	Oh.
	That's clever.
	All right.
	Let's take a vote.
	Who says yes?
	We need to keep them on the stack after evaluation.
	Who says no?
	We do not need to keep them on the stack.
	Okay.
	I saw one yes and everyone else no, basically.
	I want to know why.
	From either of you.
	Anybody who says no or yes.
	Yes?
	Yeah, that's a great idea.
	So, in the first example that we did the activity with, we had to keep that function around,
	the activation record around, where we had stored the value A is 5.
	So then when we decremented it to get A is 4, we could use that value of A is 4.
	If we had garbage collected that, we would have been done for.
	We would have gotten like a variable undefined.
	Yeah?
	Wouldn't it be easier just to store it in static memory instead so that you can keep
	the...
	Otherwise, you'd just be copying it in a separate case?
	Wouldn't it be easier to store it in static memory instead?
	Just the stuff that you would need to store for each call.
	So, if you could, at compile time, know what you needed to store, then yes.
	But you don't normally.
	But I don't know how many of these I might generate.
	Right.
	No, it's a great idea when you have knowledge about the system.
	But you don't always.
	So, yeah.
	So, if we have closures, then maybe we can't always pop these off.
	However, 95% of you said no.
	Why did you say no?
	Yeah.
	Because these are not closures.
	So, you can just pop them off.
	Is that true?
	No, I'm gonna say no on that one.
	Every function in JavaScript creates a closure.
	It doesn't matter how it's used, where it's used, what's going on.
	It is a closure.
	Yeah.
	It's an empty closure, so you don't need it anymore.
	Kind of.
	I'd say it's a specific case of the fact that it's an empty closure that we don't need anymore.
	And the key term is that it's tail recursive.
	Here, what we are doing is we are recursing in the tail position.
	Which means it's impossible for us to ever return to that closure.
	We're never going back to it.
	So, it's safe to clear.
	Generally speaking, we do need to keep activation records on the stack.
	Because they are closures.
	And we might need to reference them again.
	In this specific case, we don't.
	Okay.
	So, this process here is what we are going to continue working with for a little bit.
	But we're going to get some more interesting use cases.
	Starting with free variables, and then hopefully getting to high order functions.
	Okay.
	Let X equal 1.
	F is a function that logs X.
	Execute F.
	Question?
	Tail recursion.
	So, tail recursion is when we recurse in the last step of a function.
	So, when we are returning a recursive call.
	That is tail recursion.
	If we had written this code where we call factorial of N minus 1 as the first step.
	And then we do a check to say was N greater than or something of that sort.
	That would not be tail recursive.
	Yeah.
	Okay.
	Going back to this little code step.
	So, we have some activation record where our global state, that's the top box, has X as 1.
	And then F, when we execute it, creates an activation record with a control link back to global.
	And a return value.
	It's going to return nothing.
	What are we going to print out here?
	What's printed to screen?
	You don't have a lot of options.
	What is it?
	1.
	Yeah.
	We know the value of X.
	I feel like most of you guys knew that, but you just don't want to answer.
	It's fine to answer.
	Just raise your hand.
	Answer.
	We print out X.
	X is 1.
	So, we get the value 1.
	No tricks here.
	That's what we expect.
	How did we find X?
	Did we look it up via the control link?
	Give it a second to thought.
	Yeah.
	Go for it.
	Yes.
	Why?
	Yeah.
	So, we had access with our control to the global environment.
	And that's where X was.
	So, maybe yes.
	Any other ideas on it?
	Yeah.
	Yeah.
	So, maybe there's some concept of global that we can just use.
	But to that, I would say...
	Well, I won't write it out.
	But what if we just wrap this entire thing inside of a function?
	We would still get the value 1.
	So, it's not that global is unique.
	How many people are voting yes?
	Look it up via control link.
	How many people are voting no?
	Don't look it up via control link.
	Okay.
	So, there's like a 50-50 split.
	Why not?
	We had two arguments for yes.
	Yeah.
	I'm not quite sure I'm following.
	Yep.
	Yeah.
	Yeah, yeah, so I'm not saying that we would be moving to the outer scope or the control
	scope for execution, but just to look up a variable.
	So we'd be looking up the value X in the outer scope via the control link.
	Not that we would be going to the outer scope to execute things.
	So we won't get this kind of ping-pong.
	Yeah.
	Any other ideas?
	All right.
	My vote is no.
	And I have an example to show it.
	Well, this is going to be inconvenient.
	Is this big enough to read in the back?
	OK, cool.
	Although, now it's probably harder to read.
	Especially going all the way to the bottom there.
	But...
	All right.
	X is equal to 1.
	F is a function that prints out X.
	G is a function that sets X equal to 2.
	And then calls F. Execute G.
	That was someone next to you.
	What does this print out?
	All right.
	What are we going to draw?
	Actually, starting.
	What does it print?
	What are the options?
	What are reasonable outputs for this program?
	Yeah.
	One or two.
	I like both of those options.
	Does anybody have any other options that are reasonable for it to print?
	No.
	OK.
	Those are the reasonable options.
	Which one is it?
	How many people vote 1?
	How many people vote 2?
	OK.
	We have a little bit of dissent.
	But the vast majority look at this code and say this should print out 1.
	How?
	Let's draw our diagrams.
	And see what happens.
	We'll start with global state.
	What do we have in global state?
	X equals 1.
	Great.
	What's next?
	What's next?
	Yeah?
	Oh, yep.
	We have a function f.
	This f is a variable in our global state.
	And this is a function.
	And we're going to figure out what we're going to point to.
	But it points to something.
	What else do we have?
	Come on, guys.
	Yeah?
	We have a g.
	G is also a function.
	Excellent.
	Now what?
	We're going to call g.
	What happens when we call g?
	Yeah?
	We're going to create an activation record.
	And this will be the g activation record.
	Or the execution of g activation record.
	What's going in this one?
	X equals 2.
	We're going to call f.
	But before we get there, what else is in here?
	Return and?
	Pointer to what?
	Pointer to global.
	And what do we call it?
	The control pointer.
	And this is pointing over to global.
	Okay.
	Now we are executing f.
	What happens when we execute f?
	New activation record.
	Excellent.
	Actually, before we execute f, where is f?
	Because we're looking at this activation record.
	And we don't know where f is.
	Or what f is here.
	So if we operate under the assumption we look up the control link, we would follow the control
	link back over here and say what is f?
	F is a function.
	Great.
	Now we found f.
	We get to execute f.
	We get to create our activation record for it.
	And what do we do?
	What's inside of our activation record?
	Control link.
	What does the control point to?
	Control link points to g, because we were called from g.
	100% correct.
	That's how we establish the control link.
	What else do we have?
	Return.
	All right.
	Now we are printing out...
	Where is it?
	We are printing out x.
	What is the value of x inside of this context?
	One is what we want it to be.
	X doesn't exist here, though.
	So we have to look it up somehow.
	If we followed the control link, we would go look it up here, and we would find that
	x is equal to 2.
	Now 90% of you had the intuition that that's wrong.
	Which means we can't follow the control link, or else everyone's intuition is wrong.
	Your intuition is that way because you've seen it work that way every single time you've
	run code, unless you've worked with Lisp.
	In which case, you've seen it work this way.
	So we can't use the control link, because we would find the value 2.
	Which means we need something else.
	Let me put this down.
	So if we were following the control link, we would find x is equal to 2.
	And what we would have just done is invent what's called dynamic scoping.
	Where you can override the scoping of what would be expected of the function.
	But that's not what we want.
	This is not how normal languages function.
	This is how Lisp functions.
	It's really weird.
	And can be quite annoying.
	So how can we fix it?
	There's one more thing that we track in our activation records.
	And this is what's called the access link.
	The access link tracks the enclosing lexical scope.
	And our algorithm will be updated to first find whatever environment we are currently
	in.
	We check to see if the variable is in our environment.
	If it's not, follow our access link and repeat.
	So if we go back to our example, we start where x is equal to 1.
	We call g.
	We say x is equal to 2.
	But notice in addition to the control link, we are also storing an access link.
	And this access link is from where we were defined.
	G was defined in the global scope.
	Which means our access link points to the global scope.
	Then we call f.
	F was also defined in the global scope, which means its access link points to the global
	scope.
	The control link still points to g.
	Because we still want to return to g.
	But when we look up a variable, we will follow the access link and find that it's 1.
	Yeah?
	If x was never defined in the global environment, would it know the control link for x?
	No.
	So, yeah.
	Good question.
	If we hadn't run this line of code, what happens?
	What's output?
	In JavaScript, we call that undefined.
	We would not have been able to find x.
	We would search here for x.
	It doesn't exist.
	Then we would search global for x.
	It doesn't exist.
	We would actually search the interpreter for x.
	And the interpreter would say, hey, you're looking in a place that you aren't supposed
	to look.
	That means you have undefined.
	And it would tell the log that x is undefined.
	Okay.
	So how do we know how to wire up the access links?
	How can we figure out that f and g both have access links back to global?
	And this is what I put these arrows in for.
	When we create a function, we're defining the function f.
	We're going to create with it what I represent as a closure object.
	Which is two boxes.
	I forget which order I do these in.
	The left-hand box represents the access link for f.
	And it will point back to wherever f was defined.
	The right-hand box is the code for the function f.
	So that we know what to execute when we are executing things.
	So what does g look like?
	By this same design?
	What's the left-hand box of g?
	Yeah?
	An access link back to the global scope.
	So maybe I should be a little bit more generic when drawing these.
	It's not that it's pointing back to the variable g and f here.
	It's that it points to whatever scope it was created inside of.
	So that when we then later call f and g, we have an access link.
	Can we go look up what their access link was from their closure?
	So here, both of them are global.
	Global there.
	And global here.
	Apologies for the messy arrows.
	Any questions on access links?
	That's exactly right.
	So we set up these pieces when we create the function.
	And then we use them when we execute the function.
	It's two phases.
	There's the creation.
	And then there's the usage.
	Yeah?
	Great question.
	So this is, it goes back to our algorithm here.
	Our lookup algorithm for a variable is first what environment are we in?
	Then is the variable in our environment?
	If it is, we're done.
	If it's not, recursively apply this algorithm on the access link.
	So we will just keep going until we find it.
	And we'll take the first one that we find.
	We can't access an X from an outer scope if we have an X in our scope.
	Other questions on access links?
	Okay.
	So I've represented that over here.
	This looks very similar to what I had on the board.
	Where what we're saying is the left-hand side points to the global scope.
	The right-hand side is pointing to the literal code that we will execute when we run this
	function.
	Because functions are just a piece of data.
	I think this is all just the same thing.
	Yep.
	Environment and code.
	That is how we will handle free variables.
	Aka variables we don't have a definition for.
	All right.
	I want to pause for a minute to give you time to think of any questions you might have before
	we get into the last section of this module.
	So take a second.
	Think of any questions that might be lingering.
	Because it's only getting more complicated.
	Yeah.
	Oh, wait.
	Actually...
	Once...
	Keep thinking.
	Then I'll get you.
	Okay.
	Questions.
	You had one.
	Yeah.
	That's actually what we're about to cover.
	That is called a high-order function.
	Yep.
	So we will get to that.
	Other questions?
	The access link is the thing that most students make the mistake on when solving these problems.
	It's figuring out what's the access link and how do I use it?
	So make sure that feels clear.
	Because that's the easiest part to get tripped up on.
	All right.
	Now we have a high-order function.
	Make counter.
	Somebody walk me through this.
	Step one.
	I have global environment.
	What is in my global environment?
	X.
	What is X?
	Actually, we're ahead of ourselves by starting with X.
	What comes before X?
	Yeah.
	Make counter.
	What is make counter?
	If you don't have an answer for what is make counter, that's something that we need to
	address.
	So if this doesn't feel...
	It might feel obvious.
	You guys don't always answer my questions, even when you know the answer.
	Which is fine.
	You should.
	But if it doesn't make sense, what I'm going to draw right here, that's an indicating factor
	that you should ask me questions.
	Because it's very important that you know exactly what this is.
	So I won't call on anyone.
	But how many of you feel like you know what I'm about to put over here?
	How many of you would like me to slow down a little bit and spend a little bit more time
	on it?
	Okay.
	Now that I know that you guys are following along and just being difficult...
	What goes over here?
	Yeah.
	Go for it.
	A closure object.
	And what does it look like?
	Access link and code.
	What does the access link point to?
	Yeah.
	Global scope.
	And the code points to which lines?
	Yeah, it's the three lines...
	Like the return, open parentheses, equals, right?
	All the way down to the close with the semicolon.
	So it's those three lines.
	Okay?
	Now what?
	Established make counter.
	What else do we do?
	We have a variable X.
	What is X equal to?
	The result of make counter zero.
	All right.
	We got to figure out what that is.
	How do we figure out what make counter zero is?
	How do we do that?
	I agree.
	We want to go into make counter.
	That's a very English way of describing it.
	Exactly.
	So we're executing a function, which means we create an activation record for our make
	counter.
	So we can call this one make counter zero.
	Just so that it has a name.
	What's going inside of this activation record?
	Yeah.
	C is equal to zero.
	That's our parameter.
	What else do we have?
	Return.
	We don't know what the value is yet, but we have it.
	What else do we have?
	Yeah.
	Control.
	What does that point to?
	It points to global.
	And if we wanted to be precise, we could say it, like, points to this line of global.
	But the line number doesn't really matter.
	It points to global.
	Global.
	Great.
	What else do we have?
	Yeah.
	Access link.
	And what does that point to?
	Global.
	And how do we know that it points to global?
	It was defined in global.
	We go look up the function that we're executing.
	The function we are executing is make counter.
	Make counter is a closure that has an access link pointing to global.
	So we set it equal to global.
	Great.
	Now what?
	These are so fun.
	What do we do now that we have called make counter zero?
	We've created the activation record for it.
	What next?
	Exactly.
	So we are actually executing our code inside of make counter.
	We've set C equal to zero.
	We're on line 2, where we're returning something.
	And what we are returning is an anonymous function.
	Functions are closures.
	So what does this return look like?
	Another closure.
	So let me just draw this out a bit more precisely.
	All right.
	So it's equal to a closure.
	What are the left and right-hand sides of this closure?
	Someone knew.
	You three have done a lot.
	I appreciate it.
	Yeah.
	Yeah.
	Yeah.
	So access link points back to the activation record where it was defined.
	It was defined inside of make counter.
	So it's this one.
	Yep.
	Great.
	And what's the right-hand side?
	Yeah.
	Exactly.
	It's just that little snippet of code.
	Return C++.
	So I'll just leave it there.
	But it's the little snippet.
	Great.
	Now what?
	We want to get to make counter 2, but we have to finish out what we were in the middle
	of.
	We're done with this activation record, which means we return back, and we set x equal to
	the returned value.
	That means we're just going to have x point down to the same closure that was returned.
	Yeah.
	So x, if we wanted to look up the value of C with respect to executing x, we have captured
	it inside of this activation record.
	That is exactly correct.
	So when we go ahead and execute x, we'll see what happens.
	Let's get on to the next line, though.
	We're on to y equals make counter 2.
	What does that look like?
	Pretty much exactly like make counter 0, but C is 2.
	All right.
	Pretty much exactly like make counter 0, but C is 2.
	I accept this.
	The important point is we aren't updating this one.
	We aren't going to change this activation record.
	We're going to create an entirely new make counter 2 activation record.
	And this one will look almost identical.
	We'll say C is 2, return, we'll figure out, control is global, access is still global.
	And then the return here is to yet another new closure where the access points to that
	and the code is the C++ code.
	And then y is going to be pointing to this closure.
	Which will be hard to draw.
	So we'll name this one number 3.
	Closure number 3.
	And just say that it's number 3.
	Yeah?
	Yeah.
	So these are new activation records.
	They get their access link from how we defined make counter before.
	Yeah.
	And then I think let's execute X and follow that logic to see, like, what this leads to.
	So we get to the point of our code where we're trying to log X.
	Or log execution of X.
	What is X?
	We're in the global scope.
	What is X?
	Yeah?
	X is a pointer to a closure.
	X is a closure.
	It's specifically this one.
	What code is inside of that closure?
	Yeah.
	C++.
	So we want to execute the code C++.
	What is the value of C?
	So we're gonna create our closure here.
	X has a return, a CTL, and an access.
	What are the values of these three things?
	Let's start with control.
	What's the control pointer point to?
	Yeah.
	The make counter activation record.
	Over here.
	So control tells us where did we come from.
	Where are we coming from here?
	We're coming from global.
	We executed inside of global, which means control points to global.
	The access link, though, tells us where were we defined.
	And when we look at X, this closure was defined inside of make counter 0.
	Which means that the access link will point over to make counter 0.
	Which we'll just say MKC 0.
	So when we look up the value of C for our return, how do we find it?
	Is C in our current activation record?
	Yes?
	No.
	No, it's not.
	All we have is return control access.
	So we don't have it.
	Where do we go?
	Do we go to global?
	Or do we go to make counter 0?
	Follow the access link back to make counter 0.
	We do have C defined here.
	We're going to update the value of C, because we called C++
	to be 1.
	And then we return.
	And what is printed out?
	What's printed out?
	Tricked you.
	It's plus plus, not plus plus C. Prints out 0.
	But C will be 1.
	OK.
	So the slides for this are all up.
	You can, like, follow exactly the same logic that we took here.
	But that covers the complexity of high-order functions.
	Yeah?
	Why was there no activation record for the anonymous function?
	No activation record for the anonymous function.
	There is.
	This is the anonymous function.
	The one, the function that was defined inside.
	Why don't we make an activation record for that?
	Yeah.
	Wait.
	Hold on, guys.
	Hold on.
	Pay attention.
	This is an important question.
	Why did we not create an activation record
	when we were inside of make counter 0,
	and we were executing line 1 of make counter 0?
	Why did we not create an activation record
	for this anonymous function?
	Give it 30 seconds of thought.
	I want you to have an answer to that.
	Why did we not create an activation record
	when we were inside of make counter 0,
	when we were executing here?
	Why did we not create an activation record
	for the anonymous function?
	Give it 30 seconds of thought.
	We still have like three minutes left of class.
	Just a quick question.
	There is an activation record.
	All right.
	So I'll just do the final one.
	Yeah.
	So I'm actually going to call it a function.
	I'm going to call the function.
	It's still a function.
	Yeah.
	I'm on your side.
	Oops.
	I'm just going to put it down.
	OK.
	So I'm going to call it a statement.
	All right.
	How many people feel like they have
	a solid answer for why we did not create an activation record?
	Not enough of you.
	This is a very important question.
	So I heard the answer.
	I think you said it perfectly.
	So I want to broadcast to the class.
	Why did we not do this?
	Activation records are created when we call a function.
	Activation records are created when you call a function.
	Inside of make counter, we define an anonymous function,
	but we do not execute it.
	We do not call it, which means we don't
	create an activation record.
	Later, we execute x, and that's what actually
	creates the activation record for that anonymous function.
	Prior to that point, we never created.
	So understanding when code actually gets executed
	is hard and extremely important.
	That's like at least 50% of the things on Piazza
	where people are like, this JavaScript code isn't working.
	It's pretty often the case that it's just,
	when is that thing being executed?
	So great question.
	Any other last questions on this stuff?
	Yeah.
	What is being returned?
	Is it a pointer return?
	Yeah, so what is being returned is a closure.
	It's this whole object here.
	And we represent that as like a pointer in our diagrams.
	And JavaScript does the same thing.
	Yeah.
	Other questions on these diagrams?
	You have two of these on the homework.
	So they should make sense.
	If not, stop by office hours.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Hopefully that doesn't keep happening.
	Thank you.
	Thank you.
	All right, guys.
	Let's go ahead and get started.
	So to start off, we got some notes.
	The early deadline for the first homework and programming assignment are tomorrow.
	So that is if you want 10% bonus points, submit by tomorrow night.
	Otherwise, the normal deadline is this Sunday night at 11.59 p.m.
	So get working on those.
	I have office hours after class today.
	If you're having any trouble setting things up or have questions, feel free to stop by.
	I also have a chess board in there if you want to just sit and play chess for a little
	bit.
	Recordings.
	I missed on Monday, I forgot to set up Zoom.
	But hopefully I've contacted the department.
	That thing looks like it's on.
	I see myself in the camera over here.
	So hopefully everything will be official and through Canvas going forward.
	So use those for what you will.
	If it turns out that you guys prefer watching recordings online, that's fine.
	We'll have a little bit more of a sparse classroom.
	For the people who do show up, just come sit closer to the front and we'll have more fun.
	Okay.
	Those are my notes.
	Are there any notes from you guys?
	Anything that's not working?
	Any questions before we dive into lecture?
	Yeah?
	Is the early deadline just literally however many days beforehand and it's still midnight?
	Yes, it's still midnight.
	Yeah.
	Yep.
	The early deadline is at midnight or 11.59 p.m.
	Yeah?
	What's the name of the written assignment?
	Yeah.
	So grade scope is a little tricky.
	So the question was, if we are submitting the written assignment as a group, which you
	should definitely be submitting as a group, you need at least one group member.
	What's the process for that?
	After you submit as one person from the group, you can go to the submission and add your
	teammates to that submission.
	So one submission per group for the entire group, one submission.
	Add your teammates.
	Also select where the problem is in your submission.
	So it will say, like, where is problem one?
	And you highlight the area that is problem one.
	Yeah.
	That's all on grade scope.
	Yeah?
	Can we submit just the PA early or just the homework early?
	And do you still get the extra credit?
	Yes.
	The extra credit is tied to the individual assignment.
	So if you submit the PA early, you get 10% bonus points on the PA.
	If you submit the homework early, you get 10% bonus points on the homework.
	They're separate pieces.
	Yep.
	Anything else?
	As we get into a rhythm with it, these will be very comfortable.
	It's the same thing every time.
	All right.
	In that case, let's get back into JavaScript.
	First class functions.
	What are they?
	Who can give me the three points of what makes a first class function all at once somebody
	who didn't answer the same question yesterday?
	What is first class functions?
	What does it mean?
	Yeah.
	Go for it.
	Yeah.
	So is it using functions to create scopes for the variables inside of it?
	That's one of the things that first class functions allows us to do.
	So it's a capability of first class functions, but it's not necessarily what they are.
	Yeah?
	So it's the three things of the function can be defined in any scope, they can be passed
	to other functions as values, and they can be returned from functions as values.
	To say it in one tagline, first class functions means functions are values.
	They're just normal values.
	Just like you say let X equal 3, you can say let X equal a function.
	All right.
	So then that leads to a little bit of a pretty natural question coming after that.
	Are these functions that we're working with the same thing as function pointers that you
	might have seen in other languages like C?
	Where you can, for example, call sort with a comparison function.
	Where you tell the sort function how to sort the things in your list.
	That's using a function pointer.
	So are the functions that we're working with, these first class functions in JavaScript,
	are they just function pointers?
	This is one that I do want you to take a minute, chat with your peers, whoever's next to you,
	yes or no, and why.
	What makes it the same?
	What makes it different?
	So take a minute or two to chat.
	All right.
	Sounds like conversation is settling down.
	Let's get a quick class poll.
	How many people are in the yes camp?
	These are just like the function pointers that you would see in, for example, C.
	What about how many people are in the no camp?
	Saying these are not just function pointers.
	Something else is going on here.
	Okay.
	So large majority of the class is saying no.
	Someone explain why.
	What else is happening here?
	Yeah.
	Go for it.
	Yeah, so C definitely does not let you or at least most implementations of C do not
	let you define your functions in any scope.
	That's our first requirement for a first class function.
	So it's true C doesn't have first class functions.
	But C does let you still pass around these functions.
	And some implementations of C actually do let you define them in any scope.
	There still might be something different between a function pointer by itself being able to
	define the function anywhere and pass it around and what we're doing in JavaScript.
	There's another little piece that's happening in here.
	And we saw it yesterday with the expressive code a little bit.
	What else is going on?
	Yeah.
	Yeah.
	Yeah.
	So the function has access to variables that were around when it was defined.
	That's kind of like the English way to describe the idea of a closure.
	These functions in JavaScript are not just pointers.
	They are function code, which is what you have in C, for example, with a function pointer.
	And they also have environment.
	That is the variables that are around when the function is being defined.
	And these closures are things that we are going to deep dive into in a few lectures
	when we kind of come back to JavaScript later in, I think, late February.
	But for now, the important idea is that functions in JavaScript capture environment.
	Traditional function pointers don't.
	So you could have first class functions in some other languages and not have closures.
	JavaScript has a specific form of first class function called a closure, where we have code
	and we have environment going along with it.
	All right.
	Since it's one thing to see the slides and another thing to see code, let's dive into
	what that might actually look like.
	And you guys will have to let me know when it's the right size to read.
	How's that?
	Readable?
	All the way in the back?
	You guys can read it?
	Yep.
	Anybody want it larger?
	No.
	Okay.
	So, last time we had a function called add 42, which what it did was it took an element
	as a parameter and it returned the element plus 42.
	Nothing too special.
	But maybe we want to make a function that generically creates other add functions for
	us.
	What if we wanted an add 43 and an add 44?
	It's kind of arbitrary, definitely contrived for this example, but this type of idea exists
	all over the place.
	So what we might have is a function called make add function, and the purpose of this
	function is to return another function.
	That's one of our primary features of first class functions, is that they can be returned.
	So we're creating a function that returns another function, and importantly, we're going
	to reference a variable that does not exist inside of our scope of this function, but
	exists from the outer scope of the function that created it.
	This offset variable comes from the make add function, not the inner function that
	we're returning.
	So let's use it and see what happens.
	We can create an add 42, where we say this is equal to make add function with the value
	42, and a sub 42, where we are make add function with negative 42.
	Now when we call add 42 of 1, what are we going to get?
	Do I have copilot on?
	I do.
	That's okay.
	Turn that back off.
	I was coding earlier.
	What are we going to get here?
	43.
	Yeah.
	I think that's a fair...
	Like a reasonable assumption that we're adding 1 to add 42.
	Add 42 is this inner function here, where this x will have the value 1, and then when
	we try and look up offset, we will see that offset was 42, which was the value we were
	given.
	If we add 42 to 42, what do we get?
	84.
	Definitely.
	Same thing happens, where we're looking up the value of offset each time.
	It hasn't changed.
	We haven't updated anything.
	It's still the same value of 42.
	Just to kind of finish this, what's sub 42, 1?
	Negative 41.
	Yeah, definitely.
	This time, when we look up the value of offset, offset within the context of sub 42 is negative
	42.
	We have two different offset values.
	There's an offset that's just for this value, and there's an offset that's just for that
	value.
	And we're going to go into the mechanics of that in a future lecture.
	This one, all on the same page, that that would be 0.
	Any questions on what we've done here?
	All right, then let's make it a bit more complicated.
	See if I can get some questions out of you guys.
	These programs, once again, are all on Canvas.
	I think they weren't last time I said that.
	This time, I've double checked.
	They really should be on Canvas now.
	If they aren't, let me know, and I will try again to upload them.
	Now we're going to create a new function called f.
	Takes a parameter x.
	Then we're gonna say let y equal x.
	Okay?
	And then we're going to return a new function that's not named.
	That's fine.
	It takes a parameter z, and it assigns y equals y plus z, and then returns y.
	We call h equals f of 5.
	And then we console.log h of 3.
	Take a second.
	Think to yourself.
	First of all, what is the value of h?
	And then what will this first line print?
	So think it over to yourself for a second here.
	Try and come up with an answer.
	Who feels like they have an idea of what h is?
	Okay.
	Not too many of you.
	So I'm gonna give you a little bit more time.
	Chat with somebody next to you.
	See if you guys can come to a consensus on what h is.
	All right.
	How many people now feel like they know what h is?
	Feel a little bit more comfortable with it?
	A decent number more.
	Still not everyone, though.
	So let's figure it out.
	What is h?
	Who's got an answer?
	Yeah?
	Is it 8?
	Is it 8?
	Is h equal to 8?
	Ah.
	This one, I'm on board.
	I think this next one is 8.
	Someone else.
	What is h here?
	Yeah.
	h is a function.
	Which function is it?
	We have two functions here.
	Yeah.
	Yeah, it's this inner function, and very specifically, it's this inner function
	code in addition to the environment that says y is 5.
	Yeah.
	So that's h itself.
	The value of h.
	Then when we call h of 3, h is a function with environment.
	It's a closure.
	It's this function.
	So when we call h of 3, we say z is equal to 3.
	We will get the value 8 back out.
	Cool.
	We're good to go here.
	h is a function.
	The value here is 3.
	Now what's the value of the second line?
	Yeah.
	All the way in the back.
	12.
	Why is it 12?
	Yeah, definitely.
	So y has been updated by the previous line of code.
	y is saved in this line.
	When we say y plus equals z, we've actually updated the context.
	We've updated the environment so that now y is equal to 8.
	When we call it a second time with the value 4, we're adding 4 to 8.
	We get 12.
	That's what's returned.
	Okay.
	Let's do it one more time.
	With j equals f of 5, what is j?
	It's a function.
	Yep.
	Just like before.
	j is a function.
	And it's got y equals 5.
	The context y equals 5.
	When we call j of 3, what do we get?
	Do we get 8 or do we get 15?
	How many people vote 8?
	How many people vote 15?
	All right.
	We hardly even have to ask.
	Yeah.
	Everyone there that I saw said 8.
	We've created new context, new environment.
	That's what we're updating.
	So similarly, when we call j of 4, we're gonna end up with 12.
	Now the question is...
	What happens with this print?
	Is h equal to j?
	How many people are gonna vote yes?
	How many people are gonna vote no?
	How many people are gonna vote it depends?
	That was a trick.
	No.
	The answer here is no.
	So these two are not equivalent.
	And under no circumstance are they actually equivalent.
	Except to us as high-level reasoning beings observing the code, we can say they look very
	similar.
	They have the same code representing them.
	They currently have the same state.
	But they are not equivalent.
	They point to two different spaces in memory.
	They have two different representations.
	They are not equal.
	Yeah?
	Will we check if they have the same representation in JavaScript?
	Yeah.
	So could we make it so that these...
	This would be true.
	Yes and no.
	We could turn h and j into kind of objects that we could then write our own equals method
	for, where we would be checking to say, is the current state of these things equivalent?
	And do they then also have the same code?
	But as it stands with just them being functions, no, we can't, I don't think.
	Yeah?
	What is being compared?
	What is being compared?
	Or...
	What does it look at?
	That's a good question.
	I don't know.
	My hunch here is that it's looking at its location in memory.
	But I don't actually have a perfect answer for that.
	Yeah.
	Yeah?
	Presumably.
	Yeah.
	Like, where are these things pointing to in memory?
	I don't want to say that with 100% certainty, but that's the common approach here.
	It could also be runtime dependent.
	So node might do one thing.
	V8 might do a different thing.
	Something of the sort.
	Other questions here?
	We've discussed before that JavaScript functions don't return pointers.
	So will it really be comparing pointers?
	We've discussed before they don't return pointers?
	What do you mean?
	There was a question about pointers and functions.
	Yeah, yeah.
	So there's a difference between a pointer being a function pointer and being a pointer.
	So H and J effectively are pointers to memory, where they have code and environment information
	stored.
	That's what makes a closure.
	It's a pointer to a tuple of code and environment.
	It's not a pointer to just function code.
	That's kind of the difference there.
	Yeah.
	Would it still be a closure if it didn't update the state of Y, but it just, like,
	captured it when you passed in the value?
	So, like, it would have its own state, maybe?
	Yeah.
	So would this still be a closure if we kind of weren't doing any of this fancy Y and X
	stuff?
	Yeah.
	It definitely still is.
	Well, I meant, like, if JavaScript worked differently, where instead of it updating
	something in the scope above it, like, it just, it didn't, like, actually update it.
	So, like, if you called the first time with H or 3 and give 8, and then the second call
	would give 9, would that still be a closure?
	Yeah.
	Yeah.
	So that is still a closure, even if we aren't, even if we don't have an updatable environment.
	We still store it in environment.
	We still have that Y offset, or offset, or whatever.
	Yeah.
	Are we updating X when...
	Yeah.
	So, like, does X here change?
	My hunch is no.
	If X were an object, then potentially, yeah.
	Where these two would actually be pointing to the same object.
	But because X in this case is just, like, an integer of 5, it shouldn't be updated.
	We could test that just by putting a console log X, but I'll leave that to you guys to
	test yourself.
	I believe it is no, though.
	It is not changing.
	Any other questions?
	We'll spend a lot of time on this and, like, draw a lot of diagrams.
	So even if it's not crystal clear right now, hopefully within a few weeks, it will be.
	Yeah?
	Yeah.
	An example of how to do this before it goes away?
	Yeah.
	So why would you ever want to do this?
	That's fair.
	I do this all the time.
	Let me show you an example at the end of class of, like, actual code where I do this.
	Because it is extremely helpful to be able to, like, generate functions algorithmically.
	Or as part of your code and not have to write all of your functions yourself.
	So this idea that we want over in the first one...
	We're creating new functions every time we call make add function.
	So that I don't have to write a new add 42 function and then an add 43 function, et cetera.
	You'll often find it's the case that when you write a function, you've wanted to write
	the same thing other times.
	Or a similar thing with different state.
	And so that is exactly what this does.
	So I will search briefly at the end of class for some Python code that does something very
	similar.
	If I don't find something, I'll post on Piazza.
	Because you'll definitely want to use this.
	It'll come in handy a lot.
	All right.
	Let's get back to those slides.
	So another thing that we can use functions for is...
	We talked about scoping, where we wanted to hide our variables inside of a scope and
	not allow them to leak out to the outside scope.
	More broadly, we can use them to create modules inside of our code.
	We can represent whole chunks of our code as wrapped inside of functions that we then
	allow things to be exported from.
	So that other people can import them and use them.
	This is good for hiding information if you want to have, like, secret values inside of
	your module that you don't want other libraries to be able to access.
	It's also really useful for, like, this idea of exporting only a few functions.
	You can have a very simple exterior API, even though your interior is quite complicated
	by only exporting a few functions.
	So modules were not a part of JavaScript originally.
	But people could pretend to use them.
	I don't think this example is particularly illuminating, so I'm actually gonna skip it.
	But the module code is online, if you want to take a look.
	All right.
	So that's first class functions in JavaScript.
	There were three core ideas that JavaScript...
	We were gonna use JavaScript to show.
	One of them was these first class functions.
	Now we'll dive into objects, and then we'll cover flexibility at the very end.
	Okay.
	What are JavaScript objects?
	Simply, they are maps of names to values.
	All that an object is is a collection of property names and the value that those property
	names point to.
	So if you've used dictionaries in Python, exact same thing.
	We create them with what's called literal notation, where we can use these curly braces
	to say...
	Like, create an object.
	X is the name of the value that points to 3.
	Y points to root.
	And then you can access them by just doing .x.
	Or if you like dictionary style, you can do closing brackets with the property that you
	want.
	So that's objects in a nutshell.
	They're just maps from key to value.
	And because functions are just like values, we can have functions on our objects just
	as any other value would be.
	We could have a function...
	Object.f is a function that references the object itself.
	Any questions on objects at a first pass?
	I did want to clarify one thing I mentioned in class on Monday.
	I had talked about how...
	Actually, it might just be easier to show in code.
	So we mentioned that we could have our arrow syntax...
	This is a function that returns the value 3.
	And then I said...
	This is a function that returns an object.
	That was a slight mistake on my part.
	This is a function that returns an object with the property x pointing to 3.
	And just to clarify, this here, without the named parameter, this is a function that will
	execute the value 3.
	So it's not actually returning an object.
	It's not returning anything.
	It's just executing the value 3.
	Whatever that means.
	So we could put a console.log 3, for example, and it will execute that inner chunk of code.
	But without object syntax, we will not create the object to be returned.
	So it was a mistake fixing that for clarity.
	Okay.
	Back to the slides.
	All right.
	So we're doing something kind of neat here, though.
	We're using this.
	And you have probably used this in your other languages in Java or self in Python.
	C++ as well.
	What this actually is...
	It's coming from another language called self.
	Which is kind of funny that they have self now in Python instead of this.
	Which...
	Anyway.
	Self is from the early 90s or late 80s.
	Coming from Smalltalk, which is from the 70s.
	So from far away back there.
	We'll talk more about that when we get to object oriented programming.
	But intuitively, this is representing the object that we are currently talking about.
	So when we do this.x inside of the function assigned to the object obj, this represents
	that obj.
	The O-B-J.
	So we can reference our self.
	All right.
	We can take a quick look into receivers.
	So not too crazy.
	We can create an object using object syntax of these curly braces.
	We have three keys.
	The x, x root, f.
	They're all just initialized the same way, with comma in between any given value.
	And inside of our function f, we can reference the object that we have created.
	So if we ask what the value of x is here, it is what?
	1337.
	Right.
	Because we've defined it to be 1337 up above.
	If we call f of 3, what does this print out?
	Does it print out a function?
	So we're executing f, right?
	With the value 3.
	F itself is a function.
	But when we execute f, we will get the returned value of whatever this statement is.
	1341.
	Oops.
	1341.
	And why is that?
	Because we are incrementing the value of x.
	And then we're requesting what is the value of x.
	And then we add whatever was passed to it.
	The value of x was initially 1337.
	We increment it, making it 1330 what?
	8.
	And then we add 3 to 1338 for 1341.
	So finally, what is the last value here?
	10.
	Definitely.
	We didn't change that.
	It's the same as it's been from the start.
	So this is pretty powerful.
	But by which I mean the concept of this is pretty powerful.
	Being able to be self-referential is important for objects.
	Any questions with the receiver?
	I'm sorry.
	This started right as the drilling started.
	What was that?
	A little bit louder?
	Yeah.
	Yeah.
	So it helps update object state.
	The keyword this helps update object state.
	It also just helps reference object state.
	Maybe we just need to know what the value of x is.
	And without this, we don't really know.
	We could try and get around it by always having a second parameter to our functions.
	And then we could call obj of f of obj comma 3, for example.
	And then we'd be passing ourself to our function so that we could reference ourself's value.
	And if you're familiar with Python, you will say, hey, that looks like Python, because
	that's exactly what you're doing.
	But because you do it every time you make a function call, Python says we can just get
	rid of that object being passed in.
	Since you're doing it anyway, we'll do it under the hood for you.
	But this is exactly what you do in Python.
	And similar thing happening in JavaScript.
	Any other questions, confusions, notes?
	So we could create a function called obj.
	And it would not take any parameters.
	And it would return a function that takes a y.
	And inside of here, we could say this is equal to 10 and x equals 1337.
	And then we return x plus y.
	And we say x++.
	Is that what you're thinking?
	Yeah.
	How different are these two snippets of code?
	Yeah, so precisely.
	So we can no longer reference...
	So if we create O1 equals obj, and we can call this fun obj, maybe.
	We've actually obfuscated or hidden our values.
	If we wanted to reference x on our fun version of this object, we can't.
	We've made it secret.
	This is actually precisely where the idea of modules comes in.
	Where we've created a function to export, and it's hidden some state for us.
	So yeah.
	But similar.
	Definitely similar concepts.
	That we're returning some value that we want to work with that captures state.
	Definitely similar concepts.
	Yeah?
	Do they work similar to classes, then?
	What an excellent question.
	Where did that go?
	Keynote decided it had had enough.
	Give me a second here.
	There we go.
	So I thought JavaScript had classes.
	It does.
	Currently.
	It didn't before.
	So classes are something that are pretty convenient.
	You've seen them in so many other languages, where we have these templates for our objects.
	That we say...
	Here's a class of objects that will all look the same.
	They will all have the function f.
	They will all have the property x.
	So I want some way to easily create more of these objects.
	Before what you would have to do is instead use functions to create a constructor.
	But the key thing is that they're functionally equivalent.
	We could either use functions or we could use fancier notation with classes.
	So what is a function constructor?
	All it is is a function.
	But now any time you call that constructor, it is returning an object back to you.
	There's no fancy magic here.
	That's one of the reasons I actually really like JavaScript, especially in this context.
	There is so little magic going on behind the scenes.
	Everything is just covered by functions.
	We don't need these keywords like class or this unless we want it.
	So the one key kind of...
	One of the pieces of magic that I don't really like, though, or it's a preference thing,
	is this idea of proto.
	And proto is something that's going to bind multiple objects together to have similar
	properties.
	So that we can achieve things like classes.
	Where we can say all of the objects created here will have a color.
	All of the objects here will have the function f, for example.
	It's automatically set for us, so we can play around with it.
	And I think let's do exactly that.
	Let's play around with classes.
	So if all that we had were functions, what we might want to do is we could have a function
	car.
	And this is a constructor for a car.
	It's going to take a make and a model.
	It uses the this keyword that we were just looking at to generate an object for us of
	type car.
	This is the constructor function.
	And then we can set for all cars, my suite property is 42.
	Then we can create a new car.
	And we can execute or look at properties on that car.
	So this probably looks somewhat familiar.
	Like if you squint at it, it looks like normal object oriented stuff.
	But we're using just functions.
	And this.
	We're using the this still.
	One of the, like, under the hood things that's going on, though, is this idea of proto.
	And proto is something that's connected between all of the functions, all of the objects created
	by the same function.
	So F, which was created up above as a car, has a proto property that points to the same
	place as the car prototype.
	And why that happens is so that when we set some property on a car on the car, like, prototype,
	it sets it for all of our cars.
	So we can say things like car.prototype.color is black.
	This means that all of our cars have a black color.
	The way that this works is one of the things that we will also dive into more.
	So I don't want to kind of go too deep into it.
	But one of the neat things is that we can update and override the proto's value.
	So up above, we've said the prototype says all cars have the color black.
	However, the T car, the Toyota Corolla, is red.
	And that will update that object's version of red or that object's version of color,
	but none of the other ones.
	Yeah?
	So updating that object's color, can you do that before you set all the object's color?
	Or does it have to be after?
	Yeah.
	Yeah.
	Great question.
	So can we have set this T.color before we're setting the prototype version of the color?
	What do you guys think?
	Even if you don't know JavaScript, it's fine.
	What are your thoughts?
	Like, should this work?
	Should it not work?
	Yeah, so maybe no.
	Because then all of the other cars don't have color.
	And this object is suddenly, like, the wrong shape.
	It has a property that none of the other cars have.
	I like the sentiment.
	JavaScript says shape doesn't matter.
	And it will let you do that.
	Yeah.
	No, it is kind of funky that we can set properties on this object that no other objects would
	have.
	But JavaScript wants to be flexible.
	It wants to say do whatever you want.
	So it will let you do it.
	The question, though, that I do have for you is what is T.color here?
	What's this?
	Do we get red?
	Do we get black?
	How many people vote red?
	How many people vote black?
	Wow, okay.
	It's pretty split.
	50-50.
	All right.
	I'll hear an argument either way.
	Somebody who's voting red.
	Why is that?
	Yeah?
	Yeah, so because the T.color is overriding the prototype's color.
	That seems reasonable.
	Argument for black.
	Yeah?
	Yeah, so the prototype hasn't set the color yet.
	So once we set the color, then now that's the, like, rule of the land.
	All cars are now set to be black.
	Another thought?
	Yeah?
	Yeah, so if we create another car down here, call it A, create an accord, this color is
	what?
	It'll be black.
	Yeah.
	So here what's happening is when we look for color on the A object, we're going to
	see that A does not actually have a color, and go look to the prototype and say, what's
	the prototype say?
	And the prototype has color set as black.
	So it will print out the value black.
	If we do a console.log.
	But that's also the key idea for what is the color of T here as being red.
	Because when we go to the object, the object T has a color of red.
	If it didn't have a color set at all, then it would go to the prototype and say, what's
	the color on the prototype?
	And the color on the prototype is black.
	But because we have it set on the object itself, we're good to go.
	And this kind of prototype chasing is used for every property that you try and access
	on an object in JavaScript.
	So if you try to use T.toString, and let's say that this does not exist, if we try and
	print out T.toString, we'll check the object first.
	That doesn't have toString.
	Then we check the prototype.
	That doesn't have toString.
	But because it's an object, it has...
	The prototype itself has a prototype.
	And the prototype of the prototype is the object base class.
	And the object base class has a default implementation of toString.
	So we use that implementation.
	So it's this prototype chaining that looks like inheritance in any other language.
	Yeah?
	How does this differ from myCreate class?
	It doesn't, really.
	It's just being set on the...
	With different notation.
	Yeah.
	Question?
	So the prototype, is that an object of itself?
	Yeah.
	So char.prototype here is an object.
	When this gets to...
	I think it's on the next slide, actually.
	No.
	It's not.
	All right.
	In JavaScript, almost everything is an object.
	There are a few primitives, such as integers, characters.
	But almost everything else is treated the same way as an object.
	As a complex object.
	And that allows these kind of reuse of ideas for everything.
	We don't treat prototypes as special.
	They're just like anything else.
	Yeah?
	Yeah, I'm like 90% sure.
	Double check for me.
	But I'm 90% sure this is setting it on the prototype itself.
	All right.
	So why are objects good?
	I mean, you've been kind of indoctrinated, as we all are, as computer science majors
	or minors or just taking the class.
	When you learn programming, you start with object-oriented.
	And there's a reason for that.
	Because it's really convenient to use to organize your programs.
	It's really convenient to reuse parts of your program.
	So I don't think it's too necessary to push this point.
	It's kind of been pushed in every other class.
	So that's objects.
	The last little bit of JavaScript is about flexibility.
	These were features such as not requiring semicolons.
	If you come from C, C++, Java, which is what everyone was writing, you needed semicolons.
	JavaScript said, no, you don't.
	We can just put that in.
	The compiler is pretty smart.
	Everyone uses new lines.
	Another big one is the idea of casting.
	When you try and do string 3 plus 3, should it give you 6?
	Should it give you 33?
	I don't know.
	JavaScript will decide for you what you wanted, though.
	And maybe that's helpful.
	Maybe it's not.
	And then there's this idea of hoisting, where you don't need to declare all of your variables
	when you start your function.
	And that today sounds kind of ridiculous.
	Of course you don't.
	But some of you have probably written old C code, just because you have an old C compiler,
	where you have to put, like, all of your int x, int y at the start of your function before
	you can actually initialize them.
	You have your declaration at the top of the function, initialization down below.
	So JavaScript said, let's not do that.
	That's kind of useless.
	We can figure it out ourselves.
	Some of the other cool features.
	You can evaluate code directly in the interpreter.
	There's a function exposed to you called eval.
	And if you pass a string, a JavaScript string, to eval, it'll run it.
	That's kind of neat.
	It's kind of scary, too.
	You know?
	If you're using eval and somebody else gives you code to run, who knows what they're gonna
	do with it?
	And this idea that we could say T.color equals red before we had said that the car has a
	color.
	That's called monkey patching, where we can give variables or give properties to objects,
	whatever we want.
	And we can do it on anything.
	We can override any function that previously existed to do something else.
	The issue with that is that you can override any function that previously existed to do
	anything else.
	So when you're running JavaScript code, you can hope that it's doing what you want it
	to do.
	And nobody has messed up your objects along the way.
	But maybe they did.
	All right.
	That's a brief bit about language flexibility.
	Any questions on that side of things?
	A lot of the flexibility now feels commonplace, because we have developed more ergonomic languages
	in the last 20 years.
	But coming from the 90s, that's kind of radical.
	Now, hopefully, I would like to show you a quick video.
	This is a funny interlude before we get to something fun.
	All right.
	I don't want to make it too loud.
	Let's make sure that it's using the right sound.
	Okay.
	This is from, like, 2008, so bear with it.
	It's worth it.
	Let's talk about Ruby.
	In Ruby, if you reference an undefined variable, of course, it name errors, as you would expect.
	And if you try to assign B to A with them undefined, of course, it name errors, as you
	would expect.
	And what happens if you try to assign A to A with A undefined?
	Correct.
	Nil.
	What?
	Let's talk about Ruby.
	Ruby, unlike some other dynamic languages, does not have bare words, so you cannot just
	type words in and have strings come out.
	Unless you define a particular method missing that does the right thing.
	And then, if you type bare words, suddenly, Ruby supports bare words.
	And, in fact, it will even support bare words with bangs in them.
	And this is not deserving of Watt.
	This is actually a result of how awesome Ruby is.
	But if you ever actually do this, then, Watt.
	Let's talk about JavaScript.
	Does anyone know, in JavaScript, what array plus array is?
	Well, let me ask you this first.
	What should array plus array be?
	Empty array?
	I would also accept type error.
	That is not what array plus array is.
	Wrong.
	Wrong.
	Array plus array is empty string.
	Obviously.
	I think that's obvious to everyone.
	Now, what would array plus object be?
	This should obviously be type error, because those are completely disparate types.
	Does anyone know what this is?
	No. Close.
	No. Far away.
	It's object.
	Nicely done.
	Now, of course, because this is plus, so you can flip the operands and the same thing comes out.
	So, if we do...
	What? No, that's just an object.
	If you do object plus array, you should get exactly the same thing, which, as you can see, you do.
	And finally, the only one of these that's actually true is...
	Because, you know, you add arrays, you get empty string, that doesn't make sense.
	But an object plus an object is actually not a number, technically.
	So this one's actually right.
	Exactly, right?
	What is even going on in this lab?
	I don't even understand what person with a brain in their head would think that any of this is a good idea.
	Okay, okay.
	Enough making fun of languages that suck.
	Let's talk about JavaScript.
	If I say array.new 16, or just array 16, I get an array of 16 things, which it represents as 16 commas, which is obvious.
	And if I then join those with a string, then I get this string 16 times.
	This is actually the only line in this entire presentation that's reasonable.
	Now, if I take that string and then add a 1 to it, it interprets the 1 as...
	Or casts the 1 to a string, and then we get WAP 1 a bunch of times.
	Fine.
	Does anyone know what will happen if I subtract 1 from the string?
	I'm assuming no one does.
	I'll give you a hint.
	Does this help?
	Does anyone know?
	Does anyone know?
	All right.
	Good stuff.
	JavaScript makes a lot of sense sometimes.
	And other times makes absolutely no sense.
	But that's kind of the price we are paying with language flexibility.
	You know, it's really cool that you can add strings to numbers.
	Or subtract strings from numbers.
	Until you do it.
	And then you're like...
	Why can I do that?
	But at least your program didn't crash.
	Maybe.
	Maybe not.
	So the takeaways from JavaScript...
	That first class functions are very powerful.
	We're going to be using them a lot during this class.
	Secondly, language flexibility.
	Definitely not free.
	It's cool.
	The ability to do things that you normally can't do in other languages is great.
	But there's always a tradeoff.
	And sometimes you shouldn't add two objects and get zero.
	Who does that make sense to?
	So that is JavaScript.
	We are going to take a step away from JavaScript now.
	And we're going to go towards what PL people tend to think of when they think of PL.
	Which is a bit mathier.
	So before we step away from the good language of JavaScript,
	and familiar interpreters and things of that sort,
	are there any last questions on this area?
	Yeah?
	Yeah, yeah, yeah.
	I'll get one of those at the end of class.
	Or on Piazza later.
	Although the modules was an example of that as well.
	But I kind of skipped over that.
	Yeah?
	For like the JS code section?
	Yeah.
	I can make that work.
	We can do that.
	Let me make a note so I don't forget.
	Any other notes, questions?
	All right.
	In that case...
	We're going to start talking about what's called the Lambda Calculus.
	It's a language that was invented in the 30s.
	1930s.
	By Church.
	Alonzo Church.
	We've just seen the JavaScript functions.
	Where we were using them as first class.
	The syntax that we were kind of using sometimes was this function with, you know, parameters.
	Do something.
	We call it...
	We did a little bit of arrow function syntax that's doing the same thing.
	But looks a little bit different.
	All right.
	What we're going to start with...
	So we heat up a little bit of JavaScript.
	And what we get out is Lambda Calculus.
	Lambda Calculus is the simplest programming language.
	It has one feature.
	Functions.
	Kind of two features.
	It also has variables.
	You need variables.
	You have to have some sort of state.
	But the one real feature of it is functions.
	Why we are going to be looking at this is because it really captures the idea of first class functions.
	If all you have are functions, functions must be first class.
	Nothing else could be first class.
	So we're going to see how do variables work in almost every language.
	It's very historically important.
	It's like the genesis language for that whole family of other languages.
	Like Lisp, Scheme, ML, Haskell.
	And then it's worked its way into languages like C++.
	When you have Lambda expressions.
	Or Python.
	Or Java.
	Every language is now, if it wasn't initially built on Lambda Calculus, it's adding it in.
	All right.
	So why else?
	If you go into programming languages research, or if you read any of the papers in this space,
	they almost all, without fail, are talking about Lambda Calculus.
	It's just what people like.
	Because it's simple.
	It allows you to add a simple feature to it.
	And reason about the language without all the complexity of everything else.
	Also because it's very similar to math.
	And so people who are getting into the space are coming often from mathematics.
	They like that it's very expression focused.
	So that's another reason.
	We can also use it as a kind of underlying understanding of how various languages might implement an idea.
	So evaluation order in a language like JavaScript is very different than in Haskell.
	Lambda Calculus will show that to us very clearly.
	With the evaluation strategy.
	Additionally, we can study different type systems.
	I don't go into that in this class.
	But it's very common to talk about types in Lambda Calc.
	So that you can have different typed versions.
	Like I mentioned, almost every PL paper is built on Lambda Calculus.
	It's just the way it is.
	A necessary evil if you don't like it.
	Or once you understand it, it becomes kind of straightforward.
	If you want to do any theoretical or kind of, like, formal proof work, you will be doing it with Lambda Calculus.
	So you can study things like various types of semantics in different languages with respect to Lambda Calc.
	Okay.
	There is reading I'm going to post, I think, later today or later this week.
	That I recommend before Monday's lecture.
	That you read.
	This is a little bit of a preview of it.
	So we're going to look at the syntax or the grammar of the language.
	What is syntax in general?
	What does it mean for the syntax of Lambda Calculus to be something?
	Like, what are you looking at when you talk about syntax?
	Yeah.
	Yeah.
	How you write the language.
	What specifically, like, what symbols are you using when you are writing the language?
	For example, in math, you might say X plus Y.
	That's, like, syntactically correct.
	If you said something like plus XY, that's not syntactically correct.
	Unless you're in a reverse Polish notation system.
	In which case it would be.
	That's a different language style.
	That's different syntax.
	Okay.
	So syntax, it's about, like, the symbols you're using.
	The order that they're showing up.
	What about the semantics?
	What is the semantics of a language?
	Yeah.
	Yeah.
	Like, how to understand, like, precedence and stuff like that?
	Yeah.
	So, how to understand precedence.
	So, for example, when we do X plus Y times 2, do we evaluate X plus Y first?
	Or do we evaluate Y times 2 first?
	It really decided it was done.
	So, the semantics of the language will tell you which one goes first.
	How do we evaluate this expression?
	What else does it tell you?
	What's it about?
	When you think about semantics, what does that represent?
	Yeah.
	The meaning.
	Yeah.
	The way I associate them is very much semantics is meaning.
	Syntax is form.
	It's what it looks like versus what it represents.
	What it means underneath.
	So, semantics tells you how do you, like, what is the end result?
	What's the meaning?
	How is this thing executed?
	And I think that's probably where we're gonna stop with the slides.
	So, we...
	Because this thing is done.
	We'll try and replug it in, see if that works.
	With week 2, what we are going to be going into...
	Oh, there you go.
	It works.
	We are finishing up anyway, though.
	So, it's not a big deal here.
	With week 2, what we will be looking at is what's the syntax of lambda calc?
	And then what's the semantics of lambda calc?
	The reading that I mentioned is going to be very helpful in understanding what this line means.
	So, if this second line on the screen does not currently make perfect sense to you,
	I recommend reading the chapter that I'm going to upload.
	It'll be like a PDF.
	You know, I'm just gonna scan a book.
	If you do not have a partner for the homework assignment that's due later this week,
	please stick around and find other people who do not have a partner.
	If you have any other questions, feel free to come chat or find me in office hours right after class.
	All right.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.

	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.
	Thank you.

	Thank you.
	Thank you.
	Thank you.

	Thank you.
	Thank you.
	Thank you.

	Thank you.
	Thank you.
	Thank you.
	All right, welcome to class.
	Let's get started.
	So some of you may have seen some cool news today.
	Let me hit the lights.
	Google, or the CEO of Google, just put this out.
	An important next step for our AI journey.
	Some of you have probably been following GPT-3 and 3.5, chat GPT, that sort of stuff.
	Google has an AI model similar to GPT-3 that's literally three times larger.
	And they've had it forever.
	They just haven't been letting anybody use it.
	They announced today what they're calling BARD, which is effectively chat GPT, but Google
	branded.
	It's their version.
	With potentially a model that's significantly more powerful.
	So some fun stuff in the news today.
	We don't get access to it for a little bit longer, but that's Google for you.
	So just thought I'd give you that update in case you haven't seen it.
	Today...
	Oh, yeah?
	What do companies do keeping it internal?
	What do companies do keeping it internal?
	What do you mean?
	So something like chat GPT.
	I know it's not making any money for Microsoft just yet.
	But it's, like, good marketing.
	Right?
	But unless Google is integrating this into one of their services, what is the point of
	keeping it on your laptop?
	Yeah.
	So what's the point of keeping...
	As a business, what's the point of keeping a service that you've created internal and
	not allowing kind of open access to it?
	I think the first thing is...
	Why allow open access to something?
	The pro is...
	You might make money.
	You can potentially sell the service.
	That's great.
	The con is that people are gonna be messing around with your service.
	And maybe they're gonna be able to do things that you aren't expecting them to do.
	You might get really bad PR, especially.
	Google is very conscious of their PR.
	When it comes to AI, they don't want to be too scary.
	So keeping things internal keeps their PR presence contained.
	It means that when chat GPT says something racist or very out there and problematic,
	that's on open AI.
	Open AI has released that model.
	Anybody can use it.
	Google doesn't have that problem, because Google has not released their model.
	The benefits of keeping something internal, though, go beyond just having something internal.
	They can still use it.
	Open AI has built something that a lot of engineers are using now.
	So Copilot is something done by open AI that's great and useful.
	But beyond that, their GPT model is useful for all sorts of data processing.
	Google definitely uses Lambda, their GPT equivalent, internally to do data processing.
	Yeah.
	So there's a lot of benefit to having it.
	Even if it's not directly generating funds.
	That's not what we're talking about today.
	That's a future lecture, if we have time.
	Today, what we're talking about is fundamentals of Lambda calculus.
	Today, what we're talking about is fundamentals of Lambda calculus.
	Before we get started, a couple of quick notes.
	Homework 2 and PA2 are released.
	Homework 2 is decently harder than Homework 1.
	It's longer.
	There are more questions on it.
	Homework 1 had seven pretty short questions that you could kind of just throw into Node
	and see what happens.
	Homework 2 has, I think, four times as many questions.
	Start earlier.
	PA2, though, is a bit easier.
	It's just got, like, three or four functions that you have to implement.
	Video recordings seem to be a success.
	I have another one going now.
	So hopefully you'll always be able to watch these recordings as you study later.
	Any questions on those two before the third one?
	Oh, yeah.
	That's me.
	Sorry.
	I normally turn that off at the start of class.
	I got excited by this Google announcement.
	It's really cool.
	It's three times bigger than OpenAI.
	Not necessarily.
	No.
	It is likely better, but it's not guaranteed to be.
	Whole different training regimen.
	So...
	Could be anything.
	Questions.
	Questions.
	Questions.
	Okay.
	Then the form here that I have is a quick...
	Like it should take two minutes.
	It's a form that I have hosted on my website.
	If you go to uw.pister.dev...
	There's this DEIB form here.
	It'll take you to a Google form where I'm asking a simple set of questions.
	It's not...
	Oh.
	Okay.
	It apparently needs you to log in.
	It does not collect your email or anything of the sort.
	It's completely anonymous.
	I am not recording names or anything like that.
	But this is part of the micro grant that I received where I'm trying to figure out how
	to engage best for your learning.
	So if you could answer those questions as honestly as you can.
	If you don't have a computer with you today, I mean, you could probably do it on your phone,
	because it's a Google form.
	But the slides are up with the links, so please do it later.
	I'll give you guys two to three minutes right now, though, just to fill it out.
	Don't spend...
	You don't need to put a lot of effort.
	Just whatever first comes to mind.
	Yeah.
	Yeah.
	The link is...
	Somewhere.
	Is it working?
	You guys can access it?
	Okay.
	Okay.
	Okay.
	Okay.
	Okay.
	All right.
	If you were able to fill out the form, thank you.
	I appreciate your input.
	It will improve my teaching down the line.
	If you weren't able to fill out the form, either you need more time or you didn't have
	your computer, please find time later tonight to do that.
	It really just takes, like, two minutes.
	Now we're going to move on to LambdaCalc, though.
	So I did a sign reading.
	A sign reading.
	I uploaded, like, a few photos from my phone of a book.
	How many of you were able to read the PDF that I uploaded?
	Okay.
	Decent number of you.
	Then some decent number of you understand what this line of code means.
	But we're going to dive into it pretty explicitly.
	So what I'm saying here is an expression can become a variable X, or it can become a function
	that takes a parameter X and has an expression for a body, or it can become an expression
	with another expression passed in as an argument.
	That's the English way of reading this line of code.
	So how can we use that?
	If we wanted to...
	This is...
	Sorry.
	Backing up a step.
	This is the grammar for LambdaCalculus.
	This is the CFG, the context-free grammar, for the language LambdaCalculus.
	That's all that you need.
	So what this means is that we can start from E and turn this into a valid LambdaCalculus
	program.
	That's one step that we could take from E to generate a valid LambdaCalculus program.
	Yeah, so we can use E goes to an X and turn this into the variable X.
	X is a LambdaCalculus program.
	All it is is a variable called X.
	That's the program.
	Pretty simple.
	What if we wanted a slightly more complex program?
	What's a different step that we could take right here that would lead us down that path?
	What else could we do?
	Apply E to itself.
	So we can use this third rule to turn E into E1, E2, where these are different Es.
	What's another step that we can take from this program?
	This is a partial program.
	It's not complete.
	What can we do to this one?
	To E1, E2?
	Yeah, so let's turn this...
	Either one.
	Either one or both.
	We could turn into X.
	So we could say that this E1 becomes an X, and then we still have our E2.
	So E1, by this production rule, we could turn E into X.
	So we've turned E into X.
	We've turned E1 into X specifically.
	We still have E2.
	What else can we do to continue simplifying or turning this into a real program?
	Yeah, so let's turn this E2, using the second rule, into lambdaX.E.
	So this would turn into X, lambdaX.E.
	I'm putting parentheses just to keep that together, because this one E, E2, turned into
	lambdaX.E by our second production rule.
	But it's still not done.
	We have an E in here.
	What can we do?
	Yeah, sure, we could turn this E into an X, using the first rule.
	And our final result here would be X, lambdaX.X.
	This is another valid program in lambda calculus.
	I don't know what it means or what it does.
	Right now, we don't actually care.
	But we know that it's valid, because we used the syntax, the grammar that we've been given,
	to generate it.
	We're gonna spend a little bit more time with the slides, like, diving into what's valid,
	what's not valid.
	But these steps that we take here are the fundamental steps of developing a program
	from a grammar.
	You do it with everything that you do.
	When you write code, JavaScript has a grammar that's way more complicated than this, but
	it fundamentally turns into something like that.
	English as well has a grammar where we start from expressions and build things out with
	noun phrases and replace the noun in the noun phrase with this or that.
	So context-free grammars have applications everywhere.
	Here what we're using them for is to generate valid programs.
	Yeah?
	Yeah, so what's the deal with these 1, 2?
	Why doesn't this one have one?
	The numbers here are arbitrary.
	We could give them any name we wanted.
	We could say that this is E1, and E1 turns into E2, E3, which turns into XE3, which turns
	into E4.
	So each of these are their own expression, independent of the other expressions.
	That's what the context-free part of context-free grammar means.
	Yeah?
	Yeah, so what's the deal with this X?
	Or this X or this X, right?
	Or even this X.
	So all of these are variables in our language.
	They're just like in JavaScript when we say let X equal 3.
	This X here.
	They're the variables that are gonna capture some meaning.
	We can actually use whatever we want here.
	So we could say this is actually the variable Y.
	You know, use a different name.
	I've just put X to keep things simple.
	We can name it whatever we want.
	Just don't name it E, because E is our expression.
	I think for clarity, could you explain the difference between the X, which is a variable,
	and an expression, which is E, right?
	Right.
	So what's the difference between this and this?
	The key difference, E has somewhere to go.
	It is non-terminal.
	E can turn into one of these three things.
	X is what's called a terminal.
	There's nowhere that X can go.
	It can't turn into anything else.
	We don't have a rule that says X is equal to, I don't know, what would even make sense
	here.
	Let's say X is equal to 3.
	If we had a rule like this, that means when we're generating our program, we have to turn
	these Xs into their corresponding value, in this case, 3.
	Because we don't have a production rule with X in it, X is a terminal value, and that's
	just part of our language.
	It's a feature of our language.
	So this is the syntax.
	It's the grammar.
	Do you have another question?
	Yeah.
	Again, could you also just explain what lambda is?
	Ah, yeah, sure.
	What is lambda?
	What is dot?
	What do these things mean?
	At this point, it doesn't matter.
	We're talking not about meaning.
	We're just talking about what is valid and what's not valid.
	What programs can exist?
	The meaning is something that we're going to dive into of, like, what does each of these
	characters represent?
	But that's semantics.
	This is syntax.
	And I want those two to be pretty separate in your mind.
	What is a valid thing in lambda calculus?
	And then once I know that it's valid, what does that valid thing mean?
	The one thing that I've put in here that's not actually in our grammar is these parentheses.
	Parentheses help us just to associate things together, just like we would do in math, where
	you say, like, multiply these two things first, then do the division.
	So any time we turn E into one of these three, we're effectively putting parentheses around
	it.
	And we could, if we wanted, put parentheses around each of those production rules.
	Yeah?
	Shouldn't it just start by, like, readability, which is, like, names, and stuff like that?
	Well, so...
	Do they actually change the...?
	Right.
	Yes and no.
	And this, our equivalent...
	In this case, it is just readability.
	At some points, parentheses will matter.
	So having them helps from the start.
	But they will matter.
	Yeah.
	Okay.
	Any other questions on syntax here?
	If this is the first time you've seen context-free grammars, I recognize it's tricky.
	They're different.
	And it's a new way of expressing language.
	Read the chapter that I uploaded to Piazza.
	It's ten pages.
	It's not...
	And it's a small book.
	So it will probably take 15, 20 minutes tops.
	And it will hopefully clarify some of this.
	Yeah?
	Does the X in front of the root get the statement that's kind of part of the head, or is the
	head just the lambda X?
	The head.
	I guess, I don't know.
	I'm just trying to figure out the format of it.
	I'm trying to figure out the format of it so I can read something that says that the
	head is the lambda...
	Oh!
	In lambda calculus, you mean.
	Yeah, yeah, yeah.
	So there's...
	This is its own expression.
	This X.
	You're asking about this piece, right?
	Yeah.
	So this piece here, this lambda X dot, which corresponds to this piece here, that's what
	we're going to dive into with semantics.
	Yeah.
	Okay.
	So let's start talking about semantics.
	Because that's what you guys keep asking about.
	Which is fair.
	Because that's what the language actually is.
	Okay.
	So we've seen this grammar.
	That's what I just had up on the board.
	E can turn into a variable, which we could call X, Y, Z, whatever we wanted.
	It can turn into a function that takes a parameter named X and returns an expression E. Or it
	can turn into a function application of E1 onto E2.
	So we have variables, such as X, Y, Z.
	We have functions, or lambda abstractions is another way of saying that.
	I'm going to dive into that part next.
	But the way to, like, just very straightforwardly think of it is lambda X dot E is equivalent
	to X arrow E in JavaScript.
	We've just started working with arrow syntax.
	But if you're getting more familiar with it, that might help.
	And then the last thing that we have is function application.
	Which in JavaScript looks like E1 is the function, where E2 is the argument.
	So these are the JavaScript conversion rules.
	Okay.
	We're sticking with syntax just for a second.
	One term that we might have is something like lambda X dot 2 plus X.
	And immediately you might say, hey, wait.
	You've lied to me.
	What is 2?
	What is plus?
	We don't have those things in our language.
	We only have X, lambda X, E1, E2.
	And that's fair.
	But you can't actually represent numbers and addition with these terms alone.
	We will do that at the end of next lecture, I believe.
	So for now, just bear with me.
	We can pretend that they exist in our language as normal entities.
	So lambda X dot 2 plus X would be the equivalent of a JavaScript function that takes a variable
	X and it returns 2 plus X.
	If we wanted to call that function with the value 5, that would look something like this.
	Lambda X dot 2 plus X applied to the value 5.
	So if we looked at it in JavaScript, that would look something like X arrow 2 plus X
	with the input value of 5.
	Before we get to this complicated one...
	Oh, no?
	Okay.
	I hit it too many times.
	I want to take a step and go backwards from what we're looking at there.
	Which is hard, because they don't give us much whiteboard space.
	But we'll make it work.
	So we have lambda X dot 2 plus X applied to 5.
	They have one more set of parentheses.
	That's fine.
	So I want to use the syntax that we have, our grammar that we've defined, and break
	this apart into the rules that we have.
	Using X, lambda X dot E, and E1, E2.
	How can we reverse engineer this statement into the expressions that it's composed of?
	What would be the steps to do that?
	Yeah.
	Let's do a little bit of a simpler one.
	If we have lambda X dot X, we can go backwards from this state to our expression by saying
	this is equivalent to lambda X dot E, where we've turned E into X.
	So we're reversing our production rule.
	And then this is equivalent to E. Where E is using the production rule, E turns into
	lambda X dot E. Using the production rule, E turns into X.
	So if we started with E, we could take this step and then take that step using our production
	rules.
	I want to do that same process on this more complicated term.
	Yeah.
	Yeah, so let's turn 2 plus X into E. That's a reasonable thing to do here.
	I guess we don't need this second parenthesis anymore.
	So what we've done here is, say, we have some complicated expression, 2 plus X.
	Let's turn that into E. You know, for whatever E is.
	Then we have this step here.
	What's another backward step we can take?
	Turn 5 into E. Yeah, sure.
	This 5 can be a different E. We'll give this one a new name.
	We'll call this one E2.
	Lambda X dot E1.
	So just to keep them separate.
	They aren't the same variable E. They're a different expression.
	Yeah.
	Yeah, so this lambda X E1, we can call that E3.
	And then we still have E2.
	What's our last step?
	We know that E1, E2 is one of the productions of E. So we can generate some E4.
	So what we've done here is, we've stepped backwards from a final term, a program, into
	the base expression.
	Which means that we have a valid program in lambda calculus.
	We were able to backward step here.
	All the way to E. Yeah?
	Yeah.
	So what if...
	In JavaScript, or in any language, really, we can do something like F of 3 times 2.
	Where we have a complicated expression as a parameter to a function.
	This is an E. But it's an E in the same exact way that F of 3 is.
	Both of those are expressions that have a value.
	That we want to, you know, backwards figure out.
	Now, the specifics of how we can turn 5, which we're kind of hand waving as being part of
	our language, into E is fair.
	What I would say is...
	We can write this as a full, long lambda expression.
	But 5 is just shorter.
	To do that.
	Yeah.
	But it would look kind of like 3 times 2.
	When you write it all out.
	Other questions about this backwards process that we've taken?
	Yeah.
	The three production rules that I gave you are the three rules of lambda calculus.
	That's all that there is.
	People put more rules on top of it to create variants of lambda calculus.
	Things like typed lambda calculus or lambda calculus with objects.
	But the base lambda calculus only has those three rules.
	Other questions?
	Okay.
	In that case...
	We have another example term here.
	Lambda F dot F of 3 applied to lambda X dot X plus 1.
	Yeah?
	Yeah.
	Yeah, so we went in a very specific order here.
	Does that order matter?
	Could we have gone in another order?
	And would it have still worked?
	You are nodding.
	Right.
	Exactly.
	So we could have swapped some of these things around and done them in a different order.
	We could have done this 5 to E2 right away.
	And then done the next rule right after it.
	And that would be fine.
	That's another feature of the fact that these are context-free grammars.
	The order here doesn't matter.
	So long as you're applying the rules correctly.
	If you try and turn, like, the whole...
	Like this piece here into an expression, that's, like, cheating.
	It doesn't work in the language.
	So you'll get a different answer.
	But so long as you apply valid rules from the language, you'll always end up in the
	same place.
	Little bit of an asterisk there that we'll cover at the end of the next lecture.
	So importantly, we can't go back up any way that we want.
	Once we have created our system here, we're actually storing more information than I've
	written.
	For example, we would say this step here works so long as...
	Where can I write this?
	So long as E is equal to X plus 2.
	Or 2 plus X.
	And then we can take this next step so long as E1 is equal to...
	Oh, I guess that's what we've said here.
	So E1 equals that.
	And then E2 is equal to 5.
	And then we can take this next step so long as E3 is equal to lambdaX.E1, et cetera.
	So we're encoding that transformation in this backwards process.
	But that's not super important towards the class.
	It's just that that is the way that we're doing it.
	That's brilliant.
	All right.
	Thank you.
	Thank you for that note.
	We will use this for the next stuff on the board.
	Other questions?
	Okay.
	Then try and do this same backwards process that we've done on the second example.
	On this third one, feel free to chat with someone next to you to figure it out.
	But try and get all the way back to sum E.
	All right.
	Let's put it together as a class.
	I've got the expression up here.
	Let's go backwards.
	What's one first step that we could take?
	Yeah.
	We can turn this X plus 1 into an E1, let's say.
	LambdaX.E1.
	Okay.
	And then we keep everything else.
	Cool.
	What's another step that we could take from here?
	We could turn the 3 into an E. Yeah.
	Sure.
	So here we kind of elided that step.
	We turned our X plus 1 all into an E. That's fine.
	We can do the same...
	Over here, I guess we're going to just do the 3, and that's okay.
	So F of E2, lambdaX.E1.
	What else can we do?
	Yeah.
	Behind you.
	Sorry.
	FE2 into E4.
	Yeah.
	We can totally turn that into E4.
	Cool.
	All right.
	So that's good.
	We're good.
	We're good.
	That's fine.
	We can do that.
	All right.
	So let's...
	We can do a class.
	That's fine.
	We're good.
	Let's go back.
	What else can we do?
	Yeah.
	Oh.
	Behind you.
	Sorry.
	FE2 into E4.
	Yeah.
	We can totally turn that into E4, E3.
	And then...
	Yeah.
	One from here.
	Yep.
	Turn that into E5, E3.
	And finally...
	You guys in the back probably can't see all the way down anymore, but...
	Turn the last thing into E6.
	Why not?
	So we're able to go from this complicated expression, step by step, into a simple E6.
	And each of these E's has a different value.
	We've given it some number or some meaning inside of there.
	But we can forget about that at this point.
	The point is we were able to get down to E, which means we have a valid program.
	This is exactly the process that your IDE takes every time it gives you a redline squiggle.
	And it says, hey, your code is bad.
	You forgot to write int at the start of this line.
	Or you forgot the semicolon.
	It's going through this process constantly, trying to figure out where do you fail to
	parse your code?
	That's an error.
	Same exact process in a more complicated language.
	Okay.
	If we wanted to write that one as JavaScript, it might look something like this.
	The first part of your homework is converting JavaScript into lambda calculus.
	And then the second part is lambda calculus into JavaScript.
	So if we wanted to turn a function in JavaScript into lambda calculus, for example, function
	composition, what would function composition look like in JavaScript?
	So this is a function where we're applying f of f of x.
	F of x, instead of fog x.
	What would this look like?
	Yeah?
	Yeah, so the main function body is going to be f of f of x.
	But we're defining a function to do this.
	So we might have some sort of x goes to this result.
	It's a function that takes x and applies f of f of x to it.
	Or we might go a step further and say it's a function that takes a function f and a value
	x and then applies f of f of x.
	That's probably how I would write it in JavaScript.
	Let's see if that's what I wrote over here.
	Yes.
	Basically the same, but I've separated out the parameters.
	Questions on this composition function?
	Before we take it a step further?
	Okay.
	So...
	Oh, yeah.
	That's primarily a preference thing.
	Yeah.
	No.
	No, like, performance or readability for general people, I would assume.
	Some people prefer one way, some would prefer another.
	In some cases it matters.
	But we can talk about that later.
	All right.
	So then let's use this function.
	So the inner part here from f up to these parentheses is the same function that we've
	written already.
	But now we're calling it with two parameters.
	We're calling it with a function that takes in a variable x and returns x plus 1.
	And we're calling it with the number 4.
	Right off the bat, what would you assume this program is going to output?
	What's the return value of this final thing?
	6, right?
	We're going to call x plus 1 on 4 twice.
	So we get 4 plus 1 is 5, plus 1 is 6.
	Okay.
	So this is how we would write and then use function composition.
	In JavaScript.
	Let's do it in lambda calculus.
	Here we've seen this, like, application before, where we're passing things in.
	I guess we've done that over here.
	But the 5 is the argument.
	So what this would look like is something like lambda f dot lambda x dot f of f of x.
	And what we've done, if we look at it as a transformation, I guess I've put in these
	extra parentheses.
	We don't need to.
	In JavaScript, we had our parameters on the left-hand side of this equal sign.
	In lambda calc, we have our parameters, x and f, on the left-hand side of these periods.
	Of the DOM.
	So x and f are our parameters.
	And our return is f of f of x.
	Which is f of f of x.
	And we could, if we wanted to, put in these extra parentheses, just to make it look more
	similar.
	But that would be kind of anti-lambda calc-y.
	So we'll write it like that much more often.
	Okay.
	If we wanted to then pass in our parameters, lambda x dot or x goes to x plus 1 and
	4, that would look something like this.
	Where we're turning our x goes to x plus 1 function into lambda x dot x plus 1.
	Once again, notice the x, the parameter on the left-hand side of the equals corresponds
	to the x before the period.
	The right-hand side corresponds to the right-hand side.
	4 is 4.
	We're gonna keep going and see a lot more examples of this.
	So if it's feeling confusing, that's totally fine.
	That's very much expected, even.
	It will get less confusing the more that we look at it.
	Okay.
	And one way that we're gonna do this is just by doing a little, like, figure out is this
	valid, is this not?
	So if we had a term, lambda x plus y dot 3, is that valid?
	Give it a second of thought.
	You can try and go backwards from the final expression to an E, as we've done over here.
	If you get to E, then you're good.
	If you don't get to E, then you're bad.
	Like, I mean, the program is bad, not you.
	You guys are great.
	Thanks for showing up to class.
	But try and figure out, yes or no, is this valid?
	Okay.
	So let's do this.
	So let's do this.
	Okay.
	So let's do this.
	So let's do this.
	Okay.
	How many people are voting yes, valid term?
	How many people are voting no, not a valid term?
	All right.
	The nos have it.
	Why is it not valid?
	What's the problem here?
	Yeah, in the back.
	That's exactly right.
	So we have x plus y on the left-hand side of that dot.
	We have a rule that allows us to use lambda x dot E, but we can't turn x plus y into x.
	We could turn x plus y into E, into another expression, but that's not valid.
	That's not one of our production rules.
	So yep, not valid here.
	What about lambda x dot 3?
	How many people say yes, valid?
	No, not valid.
	All right.
	Yes, valid.
	We can turn 3 into E1, and then lambda x dot E1, we just use that second rule to turn
	it back into E. Great.
	What about lambda x x of x?
	Valid, not valid?
	How many people say valid?
	How many people say not valid?
	All right.
	A majority of valid.
	Yeah, this one is fine.
	So we can turn xx, this inside part, into E1, E2, and then E1, E2 turns into E3, and
	then lambda x E3 turns into E4.
	How about this one?
	Very similar, but we've replaced one of the x's with a y.
	Valid?
	Not valid.
	All right.
	Most people are saying valid here.
	I'm in agreement.
	The one caveat being that I've said E goes to x, so long as x is the set of variables.
	So we can name our variables anything we want.
	In this case, we're naming one of our variables y instead of x, which is fine.
	But we don't know what y is.
	But that's also fine.
	Okay.
	Any questions on any of these problems here?
	Since we're in PL, and PL people are mathematicians, and mathematicians are very tired of writing,
	there is more compact syntax.
	So for example, function application, that is E1, E2, is left associative.
	That means you perform the left application before the right-hand application.
	So E1, E2, E3 is equivalent to E1 applied to E2, the result of that applied to E3.
	So we don't need those parentheses if we don't want to use them.
	Lambdas, on the other hand, that is to say lambda abstraction or functions, bind all
	the way to the right.
	What that means is that when we have lambda x dot lambda y dot lambda z dot E, this outside
	lambda x goes all the way to the end of the E.
	We're going to go into a lot of examples of how to use this rule.
	So I'm not going to get too far into it now.
	But the trick is that you stop the, like, bounds of your lambda when you find an unmatched
	closing parentheses.
	You can think of this as the same algorithm with curly braces.
	When you open a curly brace at the start of a function, that function contains the scope
	of everything until you close the curly brace for it.
	Okay.
	So where do parentheses go in this expression?
	Lambda x dot x, x.
	Do they go around the body, the xx, or around the lambda abstraction?
	Chat with a neighbor.
	Try and come up with an answer.
	And a reason why.
	How many people say A is correct?
	How many people say B is correct?
	All right.
	Why is A correct?
	Who's got a reason for me?
	Yeah.
	Exactly.
	So lambdas bind all the way to the right until an unmatched closing parentheses.
	There are no parentheses.
	So lambdas go all the way.
	That means everything in the body is part of the lambda.
	Is this other...
	Is B a valid expression in lambda calculus?
	Yes?
	No.
	All right.
	Let's do it again.
	Is B a valid term in lambda calculus?
	Yes?
	No.
	All right.
	It is.
	It is valid.
	We could replace lambda x dot x using the second rule into E and turn x into E as well.
	E1, E2.
	So it's valid.
	It's just different.
	It's not what we were saying when we wrote that top term.
	Yeah.
	So if we didn't have...
	Oops.
	If we didn't have these two rules, it would be ambiguous to say...
	To give that term up top.
	We wouldn't know which one this is being represented by.
	But because we have these two rules, we know what that term means.
	Yeah.
	All right.
	What about this one?
	Lambda y dot lambda x, x, x.
	How many people vote A?
	How many people vote B?
	How many people vote C?
	How many people vote...
	We've spent too much time on it.
	All right.
	I mean, you guys all got it.
	This is great.
	Yeah.
	So B here, by the same logic as the previous slide, lambdas go all the way until they find
	a nonmatched closing parenthesis.
	All right.
	I think this is the last one of these.
	Are these two equivalent?
	Yes.
	They are equivalent.
	No.
	They are not equivalent.
	No.
	They are not equivalent.
	Great.
	You guys seem to be getting it.
	This is awesome.
	So the summarized rules...
	Applications are left associative.
	And precedence-wise, application happens before lambda calculus.
	I mean, lambda abstractions, sorry.
	One more way that we can make these things more compact is if we have lambda x dot lambda
	y dot lambda z dot e, we can just say lambda x, y, z.
	We aren't giving it one parameter called x, y, z.
	We're giving it three parameters, x, y, and z.
	So it's kind of the difference between this function over here, where we have two parameters
	at once.
	And if we rewrote that to be taking f, then taking x.
	Yeah?
	If you did just want one parameter called x, y, z, would you just, like, put a parenthesis
	around it?
	You wouldn't really be a mathematician then, would you?
	Honestly, I don't know what the notation...
	Like, the standard thing to do there is.
	People just always use single-letter variable names.
	Which is horrible practice.
	It's, like, exactly what you learn not to do in intro programming.
	Like, give your variables descriptive names.
	But because it's kind of math, it's, like...
	We use x, y much more often.
	I don't know.
	If you wanted, maybe, multi-character names, you could do...
	Then you wouldn't do this.
	You would keep things all separate.
	You would keep it like the left-hand side, perhaps.
	Further questions on syntax?
	Great.
	We're done with syntax.
	Let's get to the exciting thing.
	Let's actually evaluate this.
	Let's get to the semantics.
	So the semantics of lambda calc.
	There's basically one rule.
	We're going to try to reduce a term into another term as often as we can.
	Once we can't reduce it, we're done.
	That's the one rule.
	We're going to reduce a term into another term.
	Once we're done, we're done.
	The way we reduce is by rewriting terms.
	Rewriting terms means that we are doing substitution.
	Oops.
	So now what we're going to look at is what substitution means in lambda calculus.
	This is the one rule of lambda calc.
	It's the one way to do things.
	But there's a lot to it.
	So let's go through.
	So we can go back to our example over here that we had on the board.
	Lambda X dot 2 plus X of 5.
	We could rewrite that to JavaScript.
	And we would expect in JavaScript the answer to be what?
	The output of this expression to be what?
	Not a trick question.
	7.
	I heard muttered.
	So we would get to 7 by substituting X, our parameter, with the value 5.
	Because we were calling the function with the value 5.
	The same thing is going to happen.
	Or I guess...
	Actually, I think we...
	Which one goes next?
	Yeah.
	Okay.
	So in lambda calc, the same thing is going to happen.
	We're going to pass that 5 into the X.
	And we're going to get 2 plus 5, which then reduces to 7.
	So what we've done up above, which I can draw, is that we've passed 5 in for the value X.
	So lambda X dot 2 plus X applied to 5.
	This is a function.
	That's the parameter name.
	We're going to pass 5 in for X.
	And we're gonna get 2 plus 5.
	More specifically, what we would write, as an intermediate stage, is we would say we
	get 2 plus X, where X is equal to 5.
	Then we would get 2 plus 5, 7.
	Okay.
	The more complicated expression.
	In JavaScript, we have our function here with an argument here.
	What we would do is we would pass that function argument in for the value F. So we would replace
	F with the function.
	And then we would pass the 3 in for the X.
	And we'd get an output of 4.
	This is what we would do in JavaScript.
	I hope I've convinced you at this point, lambda calculus, we aren't doing anything different.
	It's the same thing as what we would do in JavaScript.
	We will pass the function argument, lambda X dot X plus 1, in for F.
	So we replace F with that value.
	Then we pass in the 3 for the X.
	Replace X with 3.
	3 plus 1.
	4.
	I'll give you a second to digest that.
	If you have any questions, feel free to ask.
	Yeah?
	It is not F multiplied by 3.
	No.
	So F3, the F space 3 in the center of that body, is...
	If we pattern matched it to our rule, we would be matching that to the E equals E1, E2 rule.
	And this is saying E1 is a function, E2 is the argument to that function.
	So we would be passing the argument 3 to the function F. Yeah.
	Any other questions here?
	Okay.
	Let's keep getting into it.
	Maybe this looks easy for now.
	Maybe it looks hard.
	If it looks hard, that's fine.
	If it looks easy, that's also fine.
	We're gonna make it a little bit trickier, though.
	But the idea that we've done here is we really just replaced the left-hand variable name
	F with the input argument.
	That's all that the substitution was.
	So substitute the term you're applying to the function for the argument variable.
	This isn't quite right, though.
	But if we wanted to use this as, like, a base, which is what we'll do, we could define E1
	with the context X equals E2 to mean replace every occurrence of X in E1 with E2.
	And this is what I've written over here.
	E1 is 2 plus X.
	X equals 5 is our X equals E2.
	So what we're saying is replace every instance of X with the value 5.
	That's like the theory way of writing it.
	Our general rule of reduction, then, would be that lambdaX.E1 being applied to E2 reduces
	to E1 where X equals E2.
	So any time we have a function application, you take the parameter name, set it equal
	to the value E2.
	So function application means rewrite E1 with every instance of X replaced with E2.
	Questions here?
	It's just like function application in other languages.
	And that's actually by design, because function applications all look the same, for the most
	part.
	Okay.
	No questions.
	That means you guys can do them.
	Take a second.
	Or take two minutes.
	Do both of these with your neighbor.
	Let's do the first one.
	What do we get as our next step of evaluation over here?
	With intermediate stages.
	What do we get?
	Yeah.
	Go for it.
	That will be...
	Give me the step right before that.
	Like the intermediate representation, which I've kind of written over there already.
	Yeah.
	Right.
	So same idea.
	2 plus X where X is equal to 5.
	And then that will reduce a second time.
	Where we can do this substitution, where we get 2 plus 5.
	Done.
	Let's do the second one.
	These are so fun.
	What can we do here?
	First of all, what's the order...
	Like, which one of these goes first?
	We got 4, 5, and 6.
	How many people...
	Well, so I guess...
	We want to figure out what goes into X.
	That's our outermost function variable.
	We have three options.
	How many people are gonna vote that it's 4?
	How many people are voting it's 5?
	How many people are voting it's 6?
	Okay.
	So we have mostly 4 with a little bit of 6.
	Why would it be 4?
	Yeah.
	Outside of parentheses, things go left to right.
	Function application is left associative.
	So that means E1, E2, E3 is equivalent to E1, E2 first, then the result of that with
	E3.
	So if we wanted to draw parentheses in here, we would do...
	If we call all of this E1, 4, 5, 6, it would be E1, 4, the result of that, 5, the result
	of that, 6.
	Okay?
	With that knowledge ahead of us, what can we do?
	How can we reduce this?
	Can you just do 1 plus 3 and then...
	You're skipping ahead a little bit.
	Give me all the simple steps in between.
	You got an idea?
	I don't know if it's just simple steps, but the...
	That's what it is.
	What do you mean?
	I mean...
	I might be misunderstanding.
	Oh, yeah, yeah.
	So we could rewrite this X, Y, Z, dot Y plus 3.
	4, 5, 6.
	These are equivalent.
	They're just different notation.
	We'll stick with the top one so that we can go one parameter at a time.
	Very clearly.
	But those are equivalent.
	Yeah?
	If you do Y, Y, dot Y plus 3, dot Y plus 3, where X is equal to 4, and 5, 6...
	Exactly.
	So we can pass just the 4 into our function.
	And what that means is that X is gonna take on the value 4.
	We're gonna be left with still a function, lambda Y, dot lambda Z, dot Y plus 3, with
	the two parameters still being passed in.
	And now we have some state that we've tacked on.
	X is equal to 4.
	What would we do next?
	Yeah?
	And what are we left with over here?
	Yep.
	So we'll keep lambda Z, dot Y plus 3 of 6.
	And now we have a state X is equal to 4.
	And Y is equal to 5.
	Okay?
	Last piece here.
	I know you guys know it.
	Oh!
	Yeah.
	Yep.
	So Y plus 3 is left.
	We have X equals 4, Y equals 5, and Z equals 6.
	We can do the last little step of 5 plus 3, because we know Y is 5.
	And we're done.
	That's what's on the slides.
	We've just done the same exact thing.
	And I've left off the state, but that's not too important.
	All right.
	One more before we finish.
	Actually, we probably don't have time before we finish.
	So we are going to continue on Wednesday doing more semantics of lambda calc.
	This is exactly what you're gonna be doing on the homework, where I will give you lambda
	calculus, you turn it into JavaScript, or I give you JavaScript, you turn it into lambda
	calculus.
	Yeah?
	So I wonder how can we go from here to this expression?
	So which one was this?
	Where we can go...
	So we have...
	What are we starting with?
	Lambda F dot F of 3 being applied to lambda X dot X plus 1.
	Right?
	Yeah.
	So...
	And we're turning them into our E1, E2, right?
	So we can turn 3 into an expression.
	Because that's just a complex expression.
	So we can say lambda F dot F of E1.
	Lambda X dot X plus 1.
	And then because of this rule here, E1, E2, we can turn these into E2, E1.
	Lambda F dot...
	Well, okay.
	I guess we're using this rule to turn F into E.
	Then we use that rule to turn E2, E1 into E3.
	And now we use the middle rule to turn that into E4.
	Yeah, that's right.
	So lambdas bind until they find an unmatched closed parenthesis.
	So this lambda here, if we take these out, this lambda here goes until it finds an unmatched
	closed parenthesis.
	So it's going...
	Unmatched closed parenthesis.
	Because it binds outside.
	So from here, goes and stops here.
	That means this is the body of the lambda.
	So that, like, this here goes all the way to that point.
	Which means we're allowed to then put in these parentheses if we want.
	Make sure you include the dot there.
	Yes.
	Yeah.
	I think it's...
	It's kind of faint there.
	I might have been...
	I might have forgotten it, but it needs to have a dot.
	Yeah.
	The dot needs to stick around.
	Yeah.
	Yep.
	Yep.
	So, like, I did this how I think it should be based on the load.json file.
	But it keeps only giving me a 2 out of 5, so I'm not sure if it's the cache being...
	Yeah.
	It looks like...
	So you need to create your own cache.
	So you want to check, like, after you do work, save that work to the cache so that the next
	time you then check to say if this work is already done in the cache, return whatever
	is in the cache.
	So you're setting cache, but you aren't checking cache.
	I think is one way to think of it.
	So if I have some...
	I'll just write Python, because that's, you know...
	Then what I can do is I can say if x in cache, return cache at x.
	Right?
	So all you need to do is check if obj is already in cache, and then just pass obj back.
	But then the important thing is also how we store that cache at x is equal to...
	Right.
	But yeah.
	So these are, like, the important before and after steps of the compute.
	But I just check first if obj is already in that.
	My hunch is that should resolve your issues.
	And then my other thing is it says that I have to use load.js file, but it's not...
	It doesn't believe that it exists.
	Like, any time I do load.js file, it says that function doesn't exist.
	Is it on...
	Is it, like, exported or something?
	No, because I'm just doing it like this, and it just says that's not...
	So have you...
	Wait.
	So you have a...
	So I believe with this one, you need to be giving it the information that it needs.
	So let me double-check on that.
	But yeah, my...
	So do we define...
	Load.js file is defined in require.
	And it's not exported for you to use somehow?
	Well, we have require saved, but even if I, like, require is as an object.
	Yeah.
	So if I use require, it doesn't exist.
	But it's exported on require.
	Like...
	You mean this?
	Yeah.
	Yeah.
	So you can't require underscore...
	Oh.
	Is load.js exported?
	No, it is not.
	I don't think so.
	Yeah.
	So I think...
	But it's on the loader.
	So the idea is we have some before where we have the normal, like, load function that
	we're running.
	Or loader function.
	And then the goal is that...
	All right.
	Let's get going.
	So as I like to do, starting with a little bit of news, is there, like, I sound louder
	to myself.
	Do I sound louder to you guys?
	No?
	Maybe that's just me.
	All right.
	There was an interesting post end of January, so a little bit ago, about Rust in business.
	A lot of people ask, like, okay, we're learning these languages, Haskell, Rust, JavaScript
	I think is pretty easy to justify.
	But do these other languages have an option?
	Especially if I'm going to an established company.
	And the answer is definitely yes.
	So AWS does a lot of Rust.
	If you've heard about Lambda, AWS Lambda, that is run entirely on a Rust service called
	Firecracker.
	Google is using Rust in Android and Chromium, as well as some of their other products.
	Huawei is using it for their operating system stuff as well.
	Facebook is using Rust for blockchain.
	Microsoft is using Rust.
	It's just every big company that you know is now using Rust.
	They're migrating away from languages like C and C++ and using Rust when they can.
	Other kind of also big companies, but maybe less well known, Shopify is huge.
	They're using Rust not as a language for their service, but as a language to compile their
	other language.
	So they use Ruby for everything.
	But they need a good Ruby compiler, so they wrote that in Rust.
	Then there are, like, a bunch of startups using Rust.
	Everybody's using Rust.
	Rust all over the place.
	Great.
	So people are using it.
	It's worth learning.
	It's also worth learning just because it's fun.
	That's the news for the day.
	Some notes.
	PA2.
	There is a deadline extension.
	This is just the programming assignment.
	Homework is still due at the normal time.
	Early deadline is still the same time.
	Programming assignment 2 makes use of ideas that we're gonna be talking about next week.
	So I'm giving you some more time to do it.
	You can probably figure it out, but it'll be easier after Monday's lecture in particular.
	Next Monday's lecture.
	So one week extension on the hard deadline.
	The early deadline is still tomorrow.
	So if you want the bonus points, do it this week.
	But getting 100% is good.
	It's good enough.
	So if you want to wait, wait.
	Either way is fine.
	PA3, though, is still due at the same time.
	So we aren't pushing all programming assignments back.
	It's just this one assignment.
	That means if you don't do PA2 this week, you have to do PA2 and PA3 next week.
	PA3 is also JavaScript.
	Lastly, programming is hard.
	A lot of you might not have worked with JavaScript very much before.
	If you're having trouble, come stop by office hours.
	Start early so that you know what you're not understanding.
	And come ask questions.
	We're here to help.
	The point of this class is not that I'm trying to teach you how to write perfect JavaScript.
	That's the point of the programming assignment.
	So I'm not gonna spend lecture time saying here's how we write JavaScript.
	That's something that you have to figure out.
	And so if you're having a hard time with that, come chat.
	Because that's where we can help you.
	Those are the notes.
	Any other questions...
	Or any questions on this stuff?
	Before we go to LambdaCalc?
	How many people have finished PA2 already?
	Okay.
	A few.
	Not too many.
	How many people have started?
	Oh, almost everybody.
	Great.
	Okay.
	That's much better than UCSD.
	There was a different culture there.
	Okay.
	So we're going to jump into LambdaCalc again.
	We started last time, we looked at syntax.
	And we said what does a LambdaCalculus program look like?
	And then towards the end of class, we started evaluating those programs.
	I want to start right where we left off of saying let's evaluate LambdaCalculus programs.
	So we're going to do these three problems.
	I believe they're new, right?
	We didn't do these three last time.
	This is where we ended.
	All right.
	So take two minutes.
	Try and work these out on your own or with somebody next to you.
	And then we'll go over them as a class.
	All right.
	It sounds pretty quiet, so I think that means that you guys are ready to go.
	Let's start off with this one.
	Who can give me first step?
	What do we want to do to start this problem?
	Yeah.
	Assign 3 to Y.
	So we're taking this 3 and we're passing it into the function LambdaY.2.
	Y is the parameter.
	So we'll have 3.
	Sure.
	So that's going to look something like LambdaX.2, where Y is equal to 3 of 5, right?
	That's what you meant?
	So we're going to say Y is equal to 3, and then we get the body of the function returned.
	What can we do from here?
	Sure.
	We can assign 5 to X.
	So we do the same process.
	Put 5 in for X.
	We get 2, where Y is equal to 3 and X is equal to 5.
	Any questions on the two steps that we've taken here?
	Because we went kind of all at once through it.
	Yeah?
	Can you explain the order of the Lambda function?
	Yeah.
	So we took a specific approach here.
	We passed 3 in for Y first.
	Could we have passed 5 in for X first instead?
	I'm seeing a lot of nodding.
	Yeah, we could have.
	We chose to do 3 goes in for Y, but we could have done it in the other order.
	And what would we have gotten if we went that way?
	It would have been the same thing.
	We would have had different intermediary steps, but we would end up with 2, where Y is 3 and
	X is 5.
	Yeah.
	We'll talk more about order towards the end of class.
	Other questions on this part?
	All right.
	Let's do the other side.
	What should we do here?
	Yeah?
	That second 2, I believe, is a 3 on the 4th.
	I believe you.
	3 gets passed to the X.
	We can look at this whole piece here as a function.
	And the 3 is the argument to the outer part of the function, the X.
	We get lambda Y dot 2, where X is equal to 3, 5.
	What can we do now?
	Pass 5 for the Y.
	And what we get at the end is we have 2 remaining, and X is equal to 3, Y is 5.
	I hate writing 5s.
	I don't know why.
	OK.
	So we get 2, Y is 3, X is 5.
	That leaves us with this last question.
	Are these two equivalent?
	And we can put those up.
	Yes?
	No?
	No.
	Why are they not equivalent?
	Yeah, the variables are different.
	On one side, we had X is 3, Y is 5.
	On the other side, Y is 3, X is 5.
	Our state is different.
	We ended up with the same final expression result, but the state that goes with that
	result is different.
	This is very similar to in closures, or in JavaScript with closures, where two functions
	might look identical, but the state that's going with them is different.
	OK.
	Let's do another one.
	Take a minute.
	Do this on your own.
	The more of these that you do, the better, more efficient, and easily they will come
	to you.
	What is state?
	What is state?
	State is the representation of the environment.
	So when we say, like, solve X plus Y, if you don't tell me what X is or what Y is, I can't
	solve this problem.
	I need some environment, some state, where I say X is 3 and Y is 2 in order to actually
	solve for this equation.
	That's a way of thinking of it.
	You can kind of reframe it as the arguments to the expression.
	But think about when you write code and you assign variables to your...
	As you're writing code, when you execute, those variables accumulate information over
	time.
	They update.
	That's the state of your program.
	Yeah.
	OK.
	Let's reduce this expression here.
	How should we start?
	A is 7.
	Yeah.
	So we'll take this 7 and substitute it in for this parameter A here.
	And we'll be left with lambda X dot X plus A of 4, where A is equal to 7.
	Great.
	What next?
	X is 4.
	We can pass in this 4 for X.
	We'll get X plus A, where our state is A is 7.
	And X is 4.
	Great.
	So when we solve it, we get 11.
	When we actually plug in our variables, we get 11.
	How did this one go?
	Any questions?
	Anything arise as you were solving it?
	Is it wrong to apply the 4 to the X first, and then 7 to A?
	Is it wrong to do 4 goes into X, and then 7 goes into A?
	No.
	No.
	That's totally fine.
	That's the way to solve this problem.
	Will the 2 always result in the same?
	No.
	No.
	But almost always.
	OK.
	Yeah.
	So 4, you'll be able to recognize when they won't.
	So in general, you can always say they will reduce to the same thing.
	Yeah.
	But we'll cover a case where they don't in the end of class.
	So what we could do is we could substitute in the 4 for the X. That's actually the way
	I have it in the slides.
	7 for the A. Get 11.
	All right.
	What about this one?
	I missed a thing here.
	What should we do first here?
	Yeah.
	Why A plus 5 to the X depends on the date that A, one of the A's to a K.
	Let's cover that second part later.
	But yes.
	We're going to apply A plus 5 to X. So we will, following the same algorithm that we've
	been using, X plus A of 7, where X is equal to A plus 5.
	All right.
	Now what do we do?
	A is 7.
	All right.
	So we get X plus A, where X is equal to A plus 5, and A equals 7.
	Now when we try to solve this, we can say, okay, X is equal to A plus 5.
	So A plus 5, gosh.
	Plus A. A is 7.
	So we get 1419.
	Yeah.
	Yeah, so is there no scope?
	This A here is, like, these guys are clearly connected.
	But what's the deal with this A?
	Is that A the same A as this A?
	Does it need to be evaluated first?
	Could we have substituted in the 7 first and then maybe avoided this whole headache?
	If we solve it the alternative way, and we do lambda X dot A plus A dot 7.
	If we plug in 7 first for A, and we get 7 plus X, and then we sub in our A plus 5 for
	X, we get a very different answer than what we got before.
	Instead of 19, which is what we got last time, this time we get 12 plus A.
	Now there was a previous question about, does order matter?
	So here we're seeing order made a difference.
	And my answer before was that it shouldn't make a difference, except in a very specific
	case.
	This is not that specific case.
	Something went wrong here.
	What we wanted to get, what we should get, is 12 plus A.
	But in the other method, going the other way, we got 19.
	A couple of you have already pointed out, maybe this is a scoping issue.
	Maybe it's because we somehow captured the second A in our inner A. And that's the right
	intuition.
	So let's play that out.
	This is...
	We kind of already answered that one.
	So what we find is that substitution is actually a little bit more complicated than what we
	thought.
	It's not just that we can take a term as an argument and pass it in.
	If we do that, we might end up with this case, where we're passing in A plus 5, and then
	somehow it gets lost inside.
	We say that in this case, the A has been captured by an inner scope.
	And we'll come back to the kind of description of this and the notation in a minute.
	Example to do at home.
	Example to do at home.
	All right.
	I like this other one more.
	Let's look at this one.
	So one way to see this same problem is in JavaScript.
	We might have a function that takes a variable X.
	And as the first line of that function, we're going to print out the value A plus 5.
	What is the value of A at the start of that function, when we're printing A plus 5?
	What's the value of A?
	Would it work?
	All right.
	Fair enough.
	Yeah.
	A is undefined at this point.
	Or maybe it is defined, but, you know, it's, like, defined up...
	Can you guys see my cursor?
	No.
	It's, like, defined up top.
	So if we said...
	If we had a...
	If we have somewhere in an outer scope, let A equal something, then we'll use whatever
	value that is.
	When we then create a new function that takes a parameter A, and we log A plus X, and we're
	calling that with the value A plus 5, what are all of these different values of A?
	This A here, this A...
	What's that A?
	Yeah?
	This A?
	Is that the parameter?
	I mean, it's, like, the argument to this function.
	Yeah.
	Yeah, it's the same A that we were initially doing a console log with.
	It's the outer scoped A. Then we have the A as the parameter.
	What's the value of that A?
	I wish these had line numbers.
	On line 4 from the top.
	Yeah?
	The outer scoped A from 5?
	Yeah.
	It'll be whatever the result of this expression is.
	All right?
	And lastly, what is this A?
	Yeah.
	It's the same A that we just talked about.
	The one before the equal sign, which is equal to the value of this A plus 5.
	So we have two different A's here, and we don't want to get them mixed up.
	This inner A is a different A than the outer A.
	The same goes for lambda calculus.
	So this function here has its own scope, and this A is equivalent to this A, but not equivalent
	to this A. This is an outer scoped A that we don't know what its value is.
	This is a defined A. It's a captured A, or bound A.
	So we don't want to mix them up.
	Here's another way to write that same idea.
	The outer function references an A that it doesn't necessarily define itself.
	It's from someone else.
	But then the inner function captures, or binds, the A as its parameter.
	OK.
	How can we fix this?
	Oh, yeah?
	Can't we just use subscripts and be done with it?
	How?
	Yeah, so give this one A1, that one A1, that one A2.
	Yeah, that's a fine idea.
	So what happens if we...
	I wish that this were actual code instead.
	So using the same A1 and A2 to reference A1 and A2.
	What happens if we do this?
	Is that readable?
	Kind of.
	That's good enough.
	So rename them with subscripts.
	What's gonna happen?
	Does it solve our problem?
	Yeah, in fact, A2 is not defined at all.
	We defined A outside, but A2 nobody's talking about.
	That's definitely undefined.
	So we will still run into a different problem when we rename this A to be A2.
	We've done something illegal.
	We've changed the name of a variable we don't control.
	It's definitely fine to call this one A1, because we control that variable.
	We control all the scoped references of it.
	This one we don't control.
	We can't change the name of.
	Which is...
	It leads perfectly into how we will fix this problem.
	So what we're gonna do is we're going to rename our variables.
	But we have to have a rule about which variables we're allowed to rename.
	Because we don't want to end up in the situation where we rename a variable that we didn't
	control and now we can't reference the variable that we wanted to reference.
	So if we have...
	This is the same problem that I was showing with JavaScript, but it's just in Haskell
	instead.
	Which we haven't covered yet.
	But the idea is the same, where we say X is equal to A plus 5, and A is 7 in X plus A.
	So we can do a renaming, a dumb renaming.
	Or a renaming and then the dumb substitution.
	Where we say...
	Okay.
	This A, we control.
	We can change that A without changing the outer A.
	And then once we do the substitution, we get the expected result.
	All right.
	So I'm arguing this will work so long as we know what variables we can and which variables
	we cannot rename.
	The reason we're going to be doing it this way...
	Or I guess...
	What are we exactly doing?
	First of all, we're talking about a variable being bound if the parameter is within the
	scope.
	So when we talk about this A here, this A is bound to this A parameter.
	This X is bound to this X parameter.
	Can we always rename bound variables?
	Yes?
	No?
	No?
	Like ten people voted.
	Think about JavaScript.
	Can we always rename X in this function?
	Or always rename A1 in the other function?
	Yes?
	No?
	Yes!
	We wrote the code.
	We get to decide.
	The parameter name is up to us.
	So we totally can.
	These are just placeholders.
	It's a parameter name.
	So we specifically say that they are equivalent by an alpha rename.
	The character is very small there.
	That is the Greek alpha symbol.
	So we can rename lambdaX.X plus Y to lambdaZ.Z plus Y.
	And what we've already started to get at is can we rename everything?
	We've seen this in JavaScript that we couldn't.
	So what can't we rename?
	Can we rename the Y in lambdaX.X plus Y?
	No.
	We don't know what it's going to be.
	Somebody else defined it, and we are just using that value.
	And what I'm trying to get at here is that you can change the name of your parameters
	and arguments.
	You can't change the name of variables in the outer scope.
	Any questions on this renaming idea?
	Yeah?
	Why do we only have access to part of the codebase?
	Why can't we change the outer A?
	Yeah?
	Yeah, so if it's something that's, like, beyond the code, kind of, it's just the string literal
	that we need to use there, I think that's a fair reason.
	Why else?
	Why else might we not have full control?
	Yeah, definitely.
	So if we were to be using any external library, any external API or other code, we don't necessarily
	control that.
	How many of you have created a file called, like, time.py or math.py in your projects?
	I feel like that's...
	I did that when I was, like, first learning how to code and got an error for, like, half
	an hour trying to figure out what's going on, and it's just because you've overwritten
	the default library for time.
	And so Python gets confused, because there's this name conflict.
	You used time when they've already defined it.
	It's the same exact fundamental problem.
	So we operate and write code in very complicated systems.
	Whether it's an interpreter or just a large codebase that you don't necessarily get to
	control everything.
	So this definitely happens.
	Where you, like, can't control all of your environment.
	Yeah.
	Any other questions on renaming?
	All right.
	We're gonna get a bit more formal, then.
	We've covered informal substitution.
	We have an idea about, okay, we can, like, substitute these things so long as we rename
	some of them sometimes.
	Let's do it in a more formal way.
	So first of all, what is a free variable?
	We've talked about bound variables.
	A variable is not bound.
	Then it is free.
	So any nonbound variable is a free variable.
	We had this expression, lambdaX.X plus Y.
	X was bound.
	Y is free.
	I answered the next question there for you.
	Let's try and solve for these two equations, though.
	So we want to be able to algorithmically find what are the free variables of an expression.
	The free variables of the expression X are X.
	If all that we have is the variable X, we have just, like, nobody's told us anything
	about it.
	It is free.
	What about the free variables of lambdaX.E. Yeah?
	Is it empty?
	That's one idea.
	Yeah?
	Every variable except for X.
	Every variable except X.
	So the, like, all what would even every variable look like?
	Something like that minus X.
	The set of all variables minus X. Yeah?
	The free variables of E minus X. Okay?
	Any other candidates?
	Yeah?
	Just E. E here is an expression.
	Not a variable.
	Just to be clear.
	But we can leave it up.
	So the expression E. Any other candidates?
	So, okay.
	Let's think about all of these.
	If we have an expression, we can just choose an expression.
	So let's use the expression X plus Y. E equals X plus Y.
	That's been our running example.
	Are the free variables of lambdaX.X plus Y, is that the empty set?
	No.
	We've said that Y is free.
	So we know Y is free, which means the free variables of this expression can't be empty.
	So we can't do that one.
	What about the set of all variables minus the free variable or minus X?
	We've captured X.
	No.
	Oh, wait.
	We're looking at
	That's okay?
	Any ideas on this one?
	No, because E might have bound variables.
	E might have bound variables.
	What if we have a different E?
	We could use lambdaZ.Z plus A. Here, Z is bound.
	A is free.
	So when we have the free variables of lambdaX.lambdaZ.Z plus A, it's not actually all variables minus
	X.
	We've also captured Z.
	Yeah?
	Yeah, so Z is bound in here, but it's not bound out here.
	Oh, that's fair.
	Yeah?
	Z, in the context of this whole function, is still free, if it exists.
	So this one doesn't actually disprove all variables minus X.
	Trying to think what a good example would be.
	I think that there actually might not be a great way of showing that this is not true.
	What we can look at is then comparing it with this next one.
	The free variables of E minus X.
	So here, what we would see is...
	I'm too low on this, aren't I?
	What would be an expression that could show that the free variables of E minus X does
	or does not work?
	Yeah?
	Wait.
	No.
	Sure.
	So if we say E is equal to X plus Y, and we look at the free variables of E, this would
	be equal to the set of X and Y.
	When we then subtract out X, we will be left with the set Y, which is what we are looking
	for.
	So this is the answer I have on my slides.
	I think this is also somewhat reasonable.
	The only thing is they aren't, like, defined there.
	Like, Z is not defined in X plus Y.
	Or it's not used in X plus Y.
	That doesn't mean it's not free in X plus Y.
	That one's thrown me for a bit of a loop.
	But the simplest set to represent the free variables of lambdaX.E are the free variables
	of E minus the variable X.
	That we capture the X from within E. Yeah?
	So if we have E is X plus Y, the free variables of E, following actually, I guess we kind
	of need this one.
	But following this, we can say that X and Y are both free.
	Inside of E.
	So X is only captured as we move out.
	Exactly.
	Yeah.
	So then we work inwards, out.
	You start at the inside and kind of grow out to your expression.
	Find what's free and what's not.
	All right.
	Doing this last one for application.
	What are the free variables of E1 applied to E2?
	Let's give ourselves some examples to see what it should be.
	We could have lambdaX, X plus Y, and Z, for example.
	So E1 is lambdaX, X plus Y, E2 is Z.
	The free variables of E1 are what?
	Y.
	So we have FV of E1 equals Y.
	What are the free variables of E2?
	Z.
	And what would we expect to be the free variables of the full expression?
	Yeah.
	Yeah, we would think they would be Y and Z.
	That in this whole part, we don't know what Z is or what Y is.
	So we have the free variables is equal to, well, here, it's equal to Y, Z, which means
	if we write it out, that it's equal to the free variables of E1 union free variables
	of E2.
	Yeah.
	Oh, oh, yeah, yeah.
	Yeah.
	What are the
	free variables of this full expression?
	X and Y.
	We have this as our equation.
	It's the union of the two sets.
	Here we have Y, here we have X.
	Even though X is bound over here, in the overall expression, X is still free.
	And that's what's going to end up causing us trouble when we try and do substitution,
	if we don't do some sort of subscript to say this one's X1.
	Other questions?
	Right.
	That's right.
	So here, this X and this X are the same.
	This X is different.
	Because it's free, yeah.
	All right.
	So the last bit of formal stuff that we do here is how can we actually define capture
	avoiding substitution?
	That is to say we don't run into our problem with the solution being 19 from earlier.
	What is the value of X where X is equal to E?
	Think of yourself as a computer trying to solve these.
	Or we have to come up with the rules so that a computer could solve these.
	What's the value of X where X is equal to E?
	E. I like it.
	We just replace X with E. That's totally fine.
	What's the value of Y where X is equal to E?
	Y if what?
	Right.
	It will remain Y so long as Y is not X.
	If Y were X, then we would use rule one.
	All right.
	What about E1 applied to E2 where X is equal to E?
	Think recursively.
	We can also do one on the board just to kind of see what happens.
	So, this is E1 applied to E2 where X is equal to 3.
	How would we simplify this expression?
	Yeah, go for it.
	Is it already simplified?
	No.
	No, there's more we can do.
	I want to substitute in this value of X.
	How do I do that?
	Our current two rules, by the way, are just those.
	Yeah?
	Is it X where Y equals X?
	X where Y equals X.
	Ah!
	So, you're, like, doing the substitution.
	So we could, like, kind of continue evaluating.
	But what I want to do, actually, is just clear up our state.
	Give all of our Xs the value 3.
	That's our goal right now.
	How can we do that?
	Would it help if you talked to the person next to you?
	Give it 30 seconds.
	What can we do here?
	Okay.
	What's the, again, algorithmic.
	Like what your computer is going to do when trying to take the next step here to simplify
	the state.
	Yeah.
	All the way in the back.
	I'm sorry.
	What was that?
	Distribute the definition to each expression.
	This is the definition?
	Yeah.
	So we can say that this is equal to lambda Y dot X, where X is equal to three, applied
	to lambda Z dot X plus Z, where X is equal to three.
	We're telling each expression that X is equal to three.
	Then if we wanted to continue, we can, you know, keep substituting, blah, blah, blah.
	But we need to be able to actually give X in each of those two contexts the value three.
	Yeah.
	I'm a little confused, because I thought we could only substitute bounds, or, like, the
	bounds are the same, so why are we assigning them to that?
	Yeah.
	Let me do that.
	Yeah.
	So are these free or bound?
	Is X free or bound in this expression?
	Free?
	Bound?
	It is actually free.
	If we look at the free variables of this expression, we would say X is free, X is free, the union
	of X and X is X.
	How would we have gotten to a state like this, though?
	Maybe it's bound in a larger function?
	It's bound in a larger function, where we've given it value.
	It's like if we go back to our JavaScript, and we have that outer let A equal.
	And we've said A is equal to three.
	Then we know exactly what to do with A. We can substitute it with three.
	So same thing's happening here.
	And one way, if we kind of, like, backstep here, we could pretend that there was a lambda
	X three, right before this step, that we've now substituted in that three for X, and so
	now we have this state, X equals three.
	This step here is very similar to what's called an eta reduction, or an eta conversion.
	But we'll cover that later.
	Yeah?
	So we can't bound it into only free variables?
	We can substitute only free variables.
	Yeah, so that's right.
	If we had, let's see, what can I do here?
	X plus lambda X dot X plus two, it doesn't make any sense anymore, because we're adding
	a function.
	But this X here is bound to this X.
	That means when we substitute X equals three, we don't want to replace this inner X with
	the value three.
	Because it's tied to a different parameter.
	It's scoped to a different parameter.
	That's just like shadowing in, like, traditional programming.
	But we haven't gotten to the lambda one yet.
	We're about to.
	Okay.
	So where we are right now is that with two expressions, we can say the X equals E distributes
	to each expression.
	Now the question that we have over here is what are we supposed to do if we have lambda
	X dot E and X is assigned a value?
	What should we get here with this substitution?
	The simplest case of this would be lambda X dot X where X is equal to two.
	What should that reduce to?
	How many people feel like they have an idea?
	How many people are confused as to what I'm asking?
	A few.
	No, it's fair.
	It's tricky.
	Especially, like, there's math notation in computer science.
	It doesn't happen very often when you're actually, like, coding.
	But some number of you had an idea.
	What are you thinking?
	Go for it.
	Yeah, it's a bound variable.
	So can't we just rename it?
	So what would happen if we say it's equal to ZZ?
	Does this make it easier?
	What should this simplify to?
	Yeah?
	Does it simplify to Z?
	So we aren't passing 2 in as a parameter.
	We have an expression and we have some state as well.
	We can push state inside the function.
	Sure.
	We can get lambdaZ.Z where X is equal to 3 inside of that Z.
	What does that simplify to?
	We can use rule number 2.
	Go for it.
	Is Z equal to X?
	No.
	Z is equal to Z. Z is Z.
	So it's equal to Z. So we can just get rid of this state.
	That's the intuitive thing to do when we're trying to substitute X equals 2 in an expression
	that doesn't use X. We can just ignore X.
	Right?
	Does that feel intuitive?
	Does it...
	Do you have questions about why we can do that?
	We're trying to say X is equal to 2, but we aren't using X.
	So within that scope, we can just ignore the fact that X is equal to 2.
	What that looks like is saying lambdaX.E, where X is equal to E, is just lambdaX.E.
	This problem started, by the way, slightly differently with XX.
	But the point was, because this X is bound to that X parameter, we were able to rename
	it.
	Which is why, then, it was very clear that we could do this.
	We can do it either way, without the rename or with the rename.
	But the rename kind of makes it a little bit clearer as to why we can do that.
	Question?
	Yeah.
	Yeah, so this X in the outer scope that is equal to E, what if this X is in E1?
	Yeah.
	Then it would be bound.
	And it wouldn't be this X. This X cannot exist inside of the scope E1.
	Any Xs inside of E1 are bound to this X or another inner X that is binding them.
	It's never going to be this X. Because that one comes first.
	It's similar to when you're writing code and you say X is equal to 3.
	That X is equal to 3, the outer ones aren't.
	Unless you're, like, doing something weird.
	All right.
	Can we get the last one here?
	What happens lambda Y dot E1 and X is equal to E2?
	Push it inside.
	Yeah.
	Maybe...
	So what we want to say is that it's lambda Y dot E1 where X is equal to E2.
	So basically what we've done is we've dropped the lambda Y as part of the consideration.
	And so then we can take another step based on whatever E1 is where X is equal to E2.
	That's what we would like to say.
	But there are some important caveats here.
	Yeah.
	Yeah.
	So can I read what I just wrote?
	Lambda Y dot E1.
	The expression lambda Y dot E1 where the state X is equal to E2.
	On the next line, we have lambda Y dot E1 where the state is X equals E2.
	So here what I'm saying is that the state is part of this expression only.
	Here what I'm saying is the state is part of the entire expression.
	We might have Y in E2.
	So Y in E2.
	What would happen if we have Y in E2?
	So if E2 is equal to exactly, for example, Y.
	Yeah.
	Yeah.
	Yeah.
	So if E2 is equal to Y, and let's say E1 equals X, then when we perform our replacement based
	on the state, we would get lambda Y dot Y as our result.
	Because E1 is X, and X is equal to E2, and E2 is equal to Y.
	So we would end up with lambda Y dot Y.
	In which case, we have captured the Y.
	Because E2 is not being controlled by this Y here.
	So this Y was free, potentially.
	Well, I guess, no, it's definitely free here.
	And then we've accidentally captured it.
	So if Y is in E2, we have an issue, and we will need to do an alpha rename on this Y.
	This Y and any Y inside of E1.
	The other case is defined by this one here.
	If Y is equal to X, then we would just use this rule instead and drop the state.
	So our expression is that lambda Y dot E1, where X is equal to E2, is equal to lambda
	Y dot E1, where X is equal to E2.
	So long as Y does not equal X, if Y equaled X, we would use this rule here.
	And so long as Y is not in the free variables of E2.
	If Y were in the free variables of E2, then we would be capturing the Y.
	Yeah?
	Just to clarify, between these last two bullet points, does the E inside of the brackets
	having a 2 or not make a difference?
	No.
	OK.
	Yeah, it's just to say that these are different E's.
	These are different E's as well.
	Those are different E's.
	Yeah.
	Yeah?
	So if Y is in the state of the free variable E2, do you just go with X?
	If Y is in the state...
	If Y is in the free variable of E2, then you would just throw away that?
	Ah, yeah.
	So what do we do if Y is in E2 here, in the free variables of E2?
	Then what we need to do is we need to actually alpha rename.
	That's when we do our renaming of this Y here and any Y in E1.
	That's the way to solve that.
	It's not that we just throw away this state.
	We can't ignore the fact that X equals E2 here.
	Because we might be using X inside of E1.
	So we have to actually rename the bound version of Y so that we can do the substitution.
	Yeah?
	Yeah.
	Yeah.
	Yeah.
	Yeah.
	So we need to rewrite the code to do it this way.
	Yeah.
	To rename the parameters.
	Yeah.
	So let's use this one.
	Yeah.
	We have a function and we have a parameter or an argument being passed in to that function.
	Our first step here is...
	Well, actually, the first thing we can do is what are the free variables of this whole
	expression?
	What are the free variables of a union of...
	Or...
	Okay.
	It's the union of an application.
	So what are the free variables of the left-hand side of this application?
	None.
	It's the empty set.
	This X here is bound by this X.
	What are the free variables of the right-hand side of the application?
	Y.
	So the free variables of the whole expression are the union of empty set and Y.
	Which means...
	Y.
	When we perform this substitution, what's the first step that we do?
	Yeah.
	Set X equal Y.
	We're gonna pass Y in for the parameter to X.
	So we're going to get lambda Y dot X, where X is equal to Y.
	What's our next step?
	Go for it.
	How about rename Y in the lambda Y?
	This Y here.
	And why do we have to do that?
	If we take a look at this example here, or this rule here, we are exactly in violation
	of it.
	Where we're trying to do lambda Y dot X, where X is equal to Y.
	And so that means Y is in the free variables of the Y.
	This Y here is in the free variables of that Y there.
	And if we don't do the renaming, then we will end up with lambda Y dot Y, where we've captured
	the Y.
	We've accidentally bound a free variable that started out free, now it's not free.
	If we rename this Y to something like Z, how can we simplify this expression?
	What rule would we use?
	We'll use the last rule, where we're saying, let's pass this state into the expression
	instead of looking at it at the whole level.
	So now we're saying X, where X equals Y.
	How do we substitute that?
	What rule do we use?
	Yeah.
	We have X, where X equals E. E in this case is Y.
	So we can do our substitution.
	We will end up with lambda Z dot Y.
	Y.
	So that's Y, the if.
	Okay.
	This largely speaking covers these first two rules.
	We have alpha rename, where we're saying we can rename any bound variable.
	And we have beta reduction, where we're saying we can actually perform an application.
	We can pass an argument into a function and then reduce it.
	The last one here is the eta conversion, which says that if we have a pattern such as lambda
	X, E of X, that can be reduced to E automatically.
	I'll leave you to figure out exactly how this works.
	I would recommend writing it in JavaScript, and then it becomes kind of apparent.
	But I'm going to stop here.
	We do have some more lambda calculus to do on Monday.
	But you are equipped to solve all of the homework assignment problems.
	Just using basically these first two techniques.
	Hey, what's up?
	Hey, what's up?
	Hey, what's up?
	Hey, what's up?
	Hey, what's up?
	Hey, what's up?
	Hey, what's up?
	Hey, what's up?
	Hey, what's up?

	Hey, what's up?
	Hey, what's up?
	Hey, what's up?
	Hey, what's up?
	So please get your laptop, please get your notepads,
	please get your laptops, please get your computers, please get
	your tablets, please get your pens and paper.
	So it's a nice major.
	We are trying to make virtual signaling easier on them.
	That's where we had helps a lot.
	But it wasn't there.
	It was more like an ARCO.
	It wasn't really that small of a balloon.
	But we got it bigger.
	And the thing is everything on Panasonic is square.
	So we were finally able to do it.
	But it took us like two weeks to get it up to here.
	All right, folks.
	Let's get started.
	Our bookkeeping before we begin lecture.
	As posted. So solutions for homeworks one and two are posted on Canvas.
	Go ahead and check them out. See how you did.
	Grading is on the way.
	For homework one, we're almost done. For homework two, we'll get there probably this week.
	PA3 and homework three are both posted to Canvas. You should have access.
	Homework three is primarily JavaScript.
	And it will be covered in the end of today's lecture and Wednesday's lecture.
	PA3 is entirely JavaScript as well.
	So over the course of the next two weeks, we're currently talking about lambda calculus.
	We're going to transition back to JavaScript for a little bit.
	And then we're going to power through to Haskell next week.
	We're going to be covering three pretty different languages in two weeks.
	If that feels confusing and hard, stop by office hours.
	In particular, Monday is generally light because the homework was just released.
	So if you want to chat about not just homework, come to my office hours after class today.
	Some general advice.
	There are a lot of people posting, my PA tests are failing on Gradescope.
	But they pass all of the local tests. What am I doing wrong?
	It's not everyone. I recognize that.
	But in general, the tests that I give you locally are not a complete test set.
	It's an idea to make sure you've written some idea of the correct function.
	The goal of Gradescope is to be the exam test.
	So you shouldn't be writing your code, submitting to Gradescope, iterating 500 times.
	It's more of write code so that it's probably done.
	Submit once. You need to fix one or two things.
	Write some more local test cases yourself to try and identify the problem.
	Then resubmit.
	So that's my advice there.
	Write local tests. Local tests, local tests, local tests.
	I don't give you everything. I just give you most things.
	Okay. Any questions for me?
	Anything that we should cover before we start class?
	Okay.
	Then hopefully today's the last lecture on LambdaCalc for a little while.
	So maybe that's good and you like that.
	Maybe that's bad because you've been loving it.
	Either way, we'll be wrapping it up.
	Starting off, we're going to talk about free variables again.
	We have three equations that we built out last time.
	I'd like for you guys to give me these two equations.
	What is the free variables of a complex expression LambdaX.E?
	What are the free variables?
	Who can tell me?
	Yeah.
	Yeah. They are the free variables of E minus X.
	We have bound X as one of the non-free variables.
	It's one of the bound variables.
	And then the free variables of a function application E1, E2 are what?
	Yeah.
	It's the union of what?
	Yeah. Definitely.
	So we find out whatever the free variables of E1 are.
	And then union that with whatever the free variables of E2 are.
	This is one set of equations that we care about in LambdaCalc.
	What are the free variables of our space?
	We did have a question on Wednesday saying,
	isn't it all of the variables?
	All variables ever?
	Not necessarily just the free variables of E.
	And to that, I would say a variable is only a variable if it's being used.
	So just for that point.
	Okay.
	This is our second set of equations.
	So our first set of equations, these ones to calculate the free variables.
	Our second set of equations are about how do we actually do substitution?
	How do we do capture avoiding substitution?
	And what do we do with these?
	What is X where X is E?
	How do we reduce the first statement?
	Who's got an answer?
	Yeah. Go for it.
	Just reduces to E.
	We get to do our replacement as you would expect.
	If X is the value 3, when we see X, we replace it with the value 3.
	For example.
	All right.
	Then we have the variable Y where X is equal to E.
	What's this reduced to?
	Who's got an answer?
	Yeah.
	Y if Y is not equal to X.
	So assuming these are two different variables, then we just get to ignore whatever we set X to be.
	Okay.
	What about E1, E2?
	Also known as a function application.
	E1, E2 where X is equal to E.
	How does this reduce?
	Yeah.
	Yeah.
	So we get to say all occurrences of X are replaced with E.
	But a little bit more generically, we say all occurrences of X in E1, we will replace with E.
	Or we'll continue to recursively substitute inside of E1, X is equal to E.
	And we will recursively substitute in E2, X is equal to E.
	All right.
	And then we have our function, our lambda abstraction.
	Lambda X.E1 where X is equal to E.
	What do we do here?
	Yeah.
	Just E1.
	Who agrees?
	So just E1.
	This is, I think, a common point of confusion.
	If I can find my pen.
	There's a meaningful difference here between lambda X.E1 with the state X is equal to E.
	And lambda X.E1 applied to E.
	This is an application, a function application, where this is an expression and this is an expression.
	This is the parameter to this function.
	Here what I'm saying is I have an expression.
	And I have some state that goes along with that expression.
	Where I can say X is equal to E inside of this expression here.
	So these are two different things that we're talking about.
	I'm looking up here.
	What do we do?
	You already got one.
	Yeah.
	E1 where X is evaluated to E.
	E1 where X is equal to E.
	What we've done here is we've lost this lambda.
	We aren't doing a function application in this expression here.
	There's no function application.
	So we should end up with a function at the end.
	We don't want to substitute in any value into this function.
	Because that's not what we're doing at this point.
	This here is what we would get if we had said, if I had kept the original thing.
	I don't know why I erased it.
	If we kept lambda X.E1, E, this would simplify to E1 where X is equal to E.
	This is our function application.
	E is a parameter to this function.
	So X is equal to E. And we get E1 where X is equal to E.
	Up here, we have an expression.
	And we have state that's going along with it.
	Yeah.
	Right.
	So when we are doing this step here, what we get to do is we get to actually drop our state entirely,
	like you've said, and get just lambda X.E1 out of it.
	Yeah, question.
	That's precisely correct.
	So this X is from an outer statement.
	It's a different X than this X.
	So one way that I personally look at this here, when I see that, I go backwards.
	And I say, how did we get here?
	We got here by having a lambda X.E.
	This is our inner expression.
	This corresponds to this piece.
	E1, sorry.
	And then we had an X, or that's an E.
	An E as a parameter to this outer function where we have X as our parameter name.
	So we can go backwards from this starting point to get to what it might have looked like before.
	Maybe it looked like this.
	Maybe it was more complicated.
	But if we simplify this line here, we would get to this point.
	OK.
	Other questions on this one?
	Because it definitely can be confusing.
	Yeah.
	So it can't be E1 and then E. What do you mean by that?
	Right.
	So why we can't say that this piece here becomes E1 where X is equal to E, or something of this sort, is because this isn't an application.
	We aren't making a function call here.
	We have an expression, and we have state that goes along with it.
	Any time you see square brackets in lambda calculus, we're talking about the state of our kind of world, of our program.
	Parentheses and all of this side, that's all the expression.
	That's the math that we're actually trying to solve.
	This is the accompanying state.
	It's not part of the expression.
	It's not something that we're going to ever substitute in.
	It's just saying this variable is equal to that.
	This variable is equal to that.
	Yeah.
	So basically, that's a bound variable, right?
	X.
	So wouldn't it be more comfortable for reading?
	We could, but we don't need to.
	Yeah.
	Yeah, so we could kind of accumulate as much state as we want.
	We could say X is equal to E, and then we'll replace this one with a Z so that eventually,
	we never rewrite this X.
	We never overwrite it.
	We could do that, but we don't need to.
	Yeah.
	So this next problem is basically the same sort of similar to this problem?
	Yes.
	So now, let's move on to this next one.
	Lambda Y dot E1, where X is equal to E2.
	How do we simplify this?
	First of all, what happens if Y is equal to X?
	Yeah.
	Right, if Y is equal to X, then we just use this rule.
	And we say, OK, Y is equal to X.
	Then we drop this state, and we'll get lambda X dot E1.
	So we can assume Y is not equal to X.
	Y is a different variable than X.
	What do we want to do now?
	Yeah, go for it.
	Drop the state.
	Well, not necessarily.
	What if E1 uses X?
	So I think let's actually take a second and look at what this would look like in JavaScript.
	You can turn this guy around.
	If I have a function that returns Y plus X, so there's a function in JavaScript.
	It takes in a parameter Y.
	It returns Y plus X.
	What if I have the state let X equal 3?
	What do I do to simplify my function here?
	Go for it.
	We can apply the state recursively to the expression.
	I love that answer for this generic thing.
	Yeah, yeah.
	So that is exactly how I would phrase it.
	I agree.
	In this example, what does that look like?
	Yeah.
	We can replace the X in our function with 3.
	So we can simplify our function to be this.
	Because we know the value of X, and we're using that variable X.
	So I want to argue that this example here is going to be identical to lambda Y dot Y plus X, where X is equal to 3.
	Here, what I have is a function that takes a parameter Y.
	It returns Y plus X.
	And I have some state that is telling me that X is equal to 3.
	This expression is equivalent to the JavaScript expression that I just showed you.
	So what we want to do is we have lambda Y dot E1, where E1 is Y plus X.
	And we have some state that X is equal to E2, where E2 is 3.
	Our goal is to get to lambda Y dot Y plus 3.
	And the way we do that is, as your classmate said, we recursively apply our substitution of X is equal to E2 inside of E1.
	So what that looks like is that we have lambda Y dot E1 with no parentheses, where X is equal to E2.
	So long as Y is not equal to X, which we already covered.
	And so long as Y is not in the free variables of E2.
	That's a confusing line of math code.
	And it might take multiple times staring at it to figure it out.
	And that's OK.
	That's expected.
	Questions on it at this point?
	Yeah?
	Well, because if Y is equal to X, we have a different rule for that, where we say just drop the state entirely.
	So we have that part covered somewhere else.
	Yeah?
	Other questions?
	Well, no, because if Y is equal to X, then we have that.
	So you would just, it's kind of like a, consider it like a case statement, where you're matching on these patterns.
	If it's this, do that.
	If it's this, do that.
	If it's this, do that.
	So maybe you could say this is redundant, because we've previously checked that Y is not equal to X.
	That's not too important to us.
	Yeah, so why don't we have this same check for this second-to-last expression?
	The reason is because we're entirely dropping the state.
	So we're never going to accidentally capture by substituting in E2.
	E2 is just kind of erased.
	Or E, in this case, is just erased.
	Yeah?
	Yeah?
	Ah, no, these are rules.
	Yes, yeah, good question.
	These are rules, not examples.
	This is the entire rule description of how we do substitution in lambda calculus.
	If it was or wasn't?
	If it was, yeah.
	So what if X is equal to, let's say, 3 plus Y?
	So now we have a complicated expression for X.
	If we perform the substitution without caring about the fact that, well, actually, first,
	is this Y free or is it bound?
	This is a free Y.
	This is a different Y than this Y.
	These two are the same Y.
	That's a different Y.
	This is a free Y.
	These are bound.
	So if we do our substitution without checking the free variables, then what we would get
	is we would get Y plus X, where X is 3 plus Y.
	And now when we look at this expression, which of these Y's is free?
	None of them.
	They're all bound.
	Or they're both bound to this Y.
	We've lost that free variable.
	And you can see this in JavaScript as well.
	If we said that X is equal to Y plus 3, this Y here is different than this Y, very clearly.
	We would have to have said somewhere else, let Y equal 7 or whatever we want.
	But if we tried to do the substitution that we did here and we said that it's instead equal to Y plus 3,
	now we've run into that same problem that we saw with lambda calculus.
	This Y is the same as this Y, even though it wasn't the same previously.
	So that's why we do this check.
	If we didn't, we would capture variables around us.
	Yeah, question.
	Yeah, no, we don't need to because it's being overwritten.
	So it's kind of what we can show this example as well with JavaScript,
	where we can say, let Y equal 3.
	And now we have a function with the parameter name Y goes to Y plus X.
	Inside of this function expression, we don't care that Y was previously equal to 3.
	We have shadowed that with our parameter name.
	So we get to ignore this previous state when we are evaluating this expression.
	That's what the second to last one is saying.
	Yeah.
	Does this make things more clear, seeing it with JavaScript?
	Is this a...
	OK, I'm seeing a lot of nods.
	That's good.
	Because I felt like Wednesday's lecture wasn't quite getting there.
	So, all right.
	At this point, we've covered the basics of LambdaCalc.
	That's everything.
	We have free variables.
	We have substitution.
	Great.
	Now, what can we do with it?
	Why did I spend two and a half lectures talking about all of this?
	Well, I guess, so first of all, the kind of specifics,
	we have the ability to do alpha renaming.
	Beta reduction is what we just defined.
	And then we have this last one, eta conversion,
	which is definitely the kind of like weird one.
	The way I think of it is, once again, with JavaScript,
	that if we have a function that takes in a variable X
	and it calls f of X,
	so if I have a function that looks like this,
	why didn't I just use f?
	Because all that I did was create a wrapper around my function f
	that took one parameter and passed it right into f.
	And I could have instead just used f.
	These are equivalent.
	That's exactly what the eta conversion is saying.
	That if we have a function that takes a single parameter
	and it has some complicated expression,
	but all that's happening is it takes in one parameter
	and passes it along to that expression,
	we can simplify that to the expression itself.
	This is not a huge thing to worry about.
	It's minorly convenient in some cases.
	So if it doesn't make full sense, that's fine.
	I would recommend just trying to play around with it a little bit,
	and that'll probably help.
	Okay.
	We did this example forever ago.
	Well, we can...
	Yeah, we can look at it again.
	So when we did this example before,
	what we found was that the A in the A plus 5
	went in for the X,
	and then we got into this problem
	where the A outside that's free was captured by the A inside.
	So what should we have done?
	What's our first step?
	Who knows?
	I heard it from someone.
	Raise your hand.
	Who was it?
	Yeah.
	We'll do an alpha rename.
	Yeah, an alpha rename of what?
	Exactly.
	We'll do an inner A,
	and we'll name it something else.
	In this case, I've called it B.
	So we just rename that inner A to be a B.
	Then we can do our substitution like normal,
	and we can pass in A plus 5 for X,
	and we can continue to beta substitute with the 7,
	and we'll end up with A plus 12.
	So that's what we should have done earlier.
	Okay.
	There's some more for the ones that,
	if you want to do them at home, feel free to.
	But that covers formal substitution,
	which leaves us with the fun part of LambdaCalc,
	why we actually talk about it.
	Well, one of the reasons that we actually talk about it
	is that we can use it to show off language paradigms.
	For example, evaluation order.
	This is a question for you guys.
	What should we reduce first in this expression?
	Yeah.
	What's that?
	The inner term.
	A.
	Who votes for A?
	Who votes for B?
	Like, mostly you guys didn't vote.
	It was like a lot of left-hand side voted for A.
	What's the reason?
	Somebody who voted,
	what's your reason for making the choice that you made?
	Did you want a third choice?
	Who wanted a third choice?
	Okay, a decent number of people wanted a third choice.
	Somebody back up your claim, whether it's A, B, or C.
	Why?
	Yeah.
	Yeah, sure.
	So one thing that we can do is we can actually solve it.
	If we take the first approach, the inner term,
	we pass z in for y.
	That reduces to z.
	Then we pass that into lambda x dot x,
	so that reduces to z.
	If we do it the other way,
	we'll pass lambda y dot yz into x,
	which gives us lambda y dot yz,
	which, when we reduce that one, also gives us z.
	They gave us the same thing either way.
	So does that mean that it doesn't matter?
	I'm seeing some nods.
	Yeah, I'm with you.
	It doesn't matter.
	They both reduce to z.
	We got the same thing.
	This is formally proved that all expressions
	will reduce to the same thing
	so long as they reduce to the same thing.
	More formally, if you reduce to a normal form,
	it doesn't matter what order you do your reductions in.
	Okay.
	So does that mean the reduction order doesn't matter?
	Yeah.
	All right.
	We have a vote for no.
	Anybody else vote for no?
	Oh, wait.
	That was a...
	Does it mean the reduction order...
	That was a vote for yes, it does matter.
	Who else votes for yes, it does matter?
	Who votes for no, it doesn't matter?
	Okay, we actually have a little bit of split.
	I do want you...
	I'll give you the answer.
	It does matter.
	No, it doesn't not matter.
	I don't know.
	It does matter.
	Why?
	You have an idea.
	Chat with the people next to you.
	Try and come up with a program that it does matter for,
	where you get a different result
	depending on how you evaluate your code.
	Chat with the people next to you.
	I'll give you like two or three minutes.
	I'm sorry to cut you off.
	You clearly have the right idea.
	I know the one, I just can't remember the exact formula.
	It's like the Y combinator.
	Yep, that's one.
	Yep, we'll cover those in a minute though.
	Okay, quieted down a bit.
	Does anybody have a good program?
	Something they want to try out?
	Who's got an idea?
	What can we try?
	For a program where it matters, what order are we going?
	You were pretty chatty 30 seconds ago.
	Something like that?
	Okay, how does evaluation order matter here?
	Ah, so let's, we're going to do proper substitution.
	So we will rename anything that we're supposed to rename.
	But definitely true that if we aren't doing proper substitution,
	we could get different results one way or the other.
	Any other ideas?
	Yeah.
	Yep.
	Yeah, so I like where you're starting here.
	The theorem there says, if you reduce to a normal form.
	So our goal is going to be trying to construct a function
	which is not reduced to a normal form.
	Not quite sure what you mean by the input-output though.
	What's, like, where they're independent?
	Won't that do what you're saying?
	But this actually is a normal form.
	Okay, so I think it's, to be honest,
	I wasn't fully expecting anyone to come up with an answer.
	But it's because it's kind of mind-boggling
	how you could come up with something
	that doesn't reduce to a normal form.
	So let's chat about a program that does this.
	The program is called Omega.
	And Omega is defined as an application of two expressions.
	You have the left-hand side, lambda x dot xx.
	And the right-hand side, lambda x dot xx.
	So what would be our first step in reducing this?
	Yeah.
	Sure, let's do an alpha rename.
	So we have lambda x, xx.
	What do you want to rename?
	I would basically give, I would number them 1, 2, 4.
	Ah, 1, 2, 3, 4.
	Yes.
	Can we do that?
	Which x is this bound by?
	The first x.
	The first x.
	Which x is this bound by?
	The first.
	Also the first one.
	So are these two x's the same?
	Yes.
	Yes.
	So we could rename these, but they have to be called the same thing.
	Yeah.
	So we could call this one x1, x1, x1.
	This one x2, x2, x2.
	Sure.
	Now what do we want to do?
	Beta reduce.
	What does beta look like?
	Yeah, so x1 is the parameter name where x1 is equal to this whole thing.
	So we will get x1, x1.
	That's our inner expression.
	x1 is equal to lambda x2 dot x2 x2.
	How do we simplify this?
	Yeah.
	Go back to where we started?
	We go back to where we started.
	Because x1 and x1 become lambda x2 dot x2 x2.
	Which we're back to the alpha renaming step again.
	Exactly.
	So if we replace this x1 with what x1 is, and we replace that x1 with what x1 is, what we end up with is this expression here.
	Which if we alpha rename, removing these numbers, is lambda x dot xx applied to lambda x dot xx.
	Which is precisely where we started.
	So if we simplify this, we end up back at omega.
	That means omega has no normal form.
	If you can beta reduce it as much as you want, you'll never end up done.
	So when we return to this question of does evaluation order matter, what if we had a function that ignores the input?
	And this is kind of what you were getting at, I feel like.
	Where we can just toss away the input.
	Lambda x dot y.
	What happens if we have lambda x dot y where the parameter is omega?
	What options do we have for reducing this expression here?
	What's one option that we have?
	Yeah.
	We could pass omega in for x and then return the result, which is y.
	We know the value.
	We're done.
	Y is the result.
	So we could return y.
	What else could we do?
	What's a different way of simplifying this problem?
	Yeah.
	Right.
	We could try and reduce omega.
	We could take a beta reduction on omega.
	What would that look like?
	We'll get the same thing.
	Reducing omega gives you omega back.
	OK, so now we're here.
	What could we do?
	What options do we have?
	The same thing.
	Once again, return y by passing omega in for x, and then ignoring x and returning y.
	Or we could try and reduce it again, and again, and again, and again.
	At each stage, we have a choice to make.
	If you're familiar with non-determinism in Turing machines, this might look pretty familiar.
	Where it's like we could take that jump, or we could just stay where we are and kind of sit doing nothing with our epsilon.
	So, does it matter?
	Yes.
	Does it not matter?
	No.
	It does matter.
	But it only matters sometimes.
	And most of the time, we can say whatever.
	Sometimes, in lambda calc, we have to be pretty precise.
	So we can come up with a few different strategies.
	The first of which is called call by value.
	This is JavaScript's and most languages' approach.
	Where we have a function application, E1, E2.
	What we will do is first reduce the function.
	Then reduce the arguments.
	Then apply.
	So, any time you're doing a function application, you simplify both sides before applying the actual function call.
	We can think of this as...
	If we have JavaScript goes to X plus 3, whatever.
	So, we have some function.
	And we're going to call it with 3 plus 4.
	We will simplify our function, which we can't do.
	There's no simplification to be made.
	Then we simplify the arguments.
	And we figure out that this is 7.
	Then we pass 7 in for X.
	We could instead pass the expression 3 plus 4 in for X.
	We would get the same thing here.
	But that's a different route that we could take.
	JavaScript says reduce the arguments.
	Then apply.
	So, if we...
	You know, like, following that, we simplify the red.
	Then we simplify the blue.
	Then we apply the thing.
	So, if we look at this JavaScript function.
	X goes to 33 with this parameter as input.
	What are we going to get as our result?
	You have to turn on your visual debugger.
	What do we get?
	Who's got an idea?
	One person.
	Chat with somebody next to you.
	Figure out.
	What does this give us?
	How many of you said this?
	Range error maximum call stack exceeded.
	Why?
	What happened here?
	Where did we go wrong?
	Yeah?
	Exactly.
	No, no, no.
	So, we're trying to reduce the right-hand side value in blue.
	And this is a recursive function.
	What is this function?
	What's another name for the blue part?
	Yeah.
	Omega.
	That's what we just saw.
	In lambda calculus.
	That's omega.
	In JavaScript.
	Yeah, so it's not gonna work.
	What if we wanted it to work?
	Haskell, which we will start studying soon, takes a different approach.
	That's more similar to call by name.
	Where what we do is we reduce the function.
	And then we apply.
	The only thing that's different than call by value is that we aren't reducing the argument.
	You don't reduce the argument ever.
	You only ever reduce the function.
	And what that means is we will only use a value if it's being used.
	To go to our example over here, which was bad JavaScript.
	If we have a function X goes to 3, and we pass in 3 plus 4, but we aren't using X, why would you evaluate 3 plus 4?
	We didn't need that.
	Wasted computation.
	Ice caps are melting and all that, you know?
	This 3 plus 4 is the fault.
	So we can just toss it out instead because it's never used.
	Never evaluate something if it's not gonna be used.
	So this is your first, for some of you, your first time ever seeing Haskell.
	But it looks surprisingly similar to lambda calculus.
	Where we have lambda X dot 33, lambda X dot XX, lambda X dot XX.
	What will this program evaluate to?
	If you know nothing about Haskell except for what I've just said up above.
	Yeah?
	33.
	Because we don't use our parameter X, this piece here being omega, we'll never reduce omega.
	Which means we'll never try to go into this infinite loop, and we'll end up with the value 33.
	Now you guys know Haskell.
	That wasn't so hard.
	All right.
	Questions?
	Is there any of this?
	Yeah.
	No.
	That's...
	Yeah?
	Yeah.
	No.
	So it'll do the beta reduction to pass this all in for X.
	And then it won't need to use X.
	So it will never evaluate that state.
	So up above what you can see, only the pointer worked.
	We evaluate the left-hand side, the red.
	Simplify that as much as we can.
	And then the beauty of it is that we get to this E1 prime 33, where X is equal to this
	omega.
	And since we never use X, we can just toss away the state.
	And we'll return 33.
	Yeah?
	What do you mean by sharing?
	Oh, yeah, yeah.
	So what if...
	What if we have a function that takes X and returns X plus X?
	Then it's great to precompute 3 plus 4.
	Now we're saving the polarized caps.
	Because we're doing 7 plus 7 instead of 3 plus 4 plus 3 plus 4.
	And if you do 3 plus 4 plus 3 plus 4, you've duplicated your computation.
	Which might seem trivial, but I promise you it's not.
	This is exactly what compilers are doing all the time to optimize your code.
	So what Haskell does is it says, until you need something, don't evaluate it.
	As soon as you need it, store it.
	So we're gonna compute 3 plus 4 for X.
	And then we're just gonna use that same value a second time.
	We don't need to recompute it.
	So that's what the sharing means.
	Yeah?
	So, no, that's part of the runtime environment.
	But well, to the extent it can do these things at compile time, it will.
	But it can't do everything.
	Other questions?
	Cool.
	So in summary, you can have the technical term redexes or some terms that can reduce.
	Your evaluation strategy tells you which term to evaluate and reduce.
	You aren't guaranteed to find a normal form.
	These are two different ways that you could...
	Two different strategies to solve lambda expressions.
	All right.
	That concludes lambda calc.
	However, in the slide deck, there are about 15 more slides about more fun things you can
	do with lambda calculus, such as creating booleans, creating numbers, creating functions
	we've already done, doing tuples, structs, and in particular, recursion, which is not
	required for the course and will not be part of standard exam points.
	There's some fun slides on it, too.
	We talked about the Y Combinator, but not the VC firm.
	So I would encourage you, if you have at all enjoyed lambda calc, or if it's just at all
	interesting to check it out.
	Those last few slides.
	But otherwise, we're going to be leaving lambda calc in its place and use it as a way of talking
	about some of these other ideas.
	So any lingering questions on lambda calc?
	Yeah.
	So what should you take away from lambda calc?
	I think it's a fair question.
	First of all, for the exam, but also more broadly speaking, the goal of a lot of the
	parts of this class are to improve your visual debugger, as I mentioned as I brought up
	earlier.
	Where it's not necessarily that you're ever going to write lambda calc.
	But you will look at a lot of functions as software engineers.
	That's something that you will do.
	And being able to spot how they work and what they're doing and how things will evaluate
	is very important.
	With respect to your grade, you need to be able to evaluate a lambda calc expression.
	And say what are the free variables of this expression?
	What will it reduce to?
	Will it reduce?
	Or will it not reduce?
	That sort of thing.
	Or write a lambda calc expression that does X, Y, Z.
	That's the sum of it.
	Other last questions?
	Otherwise, feel free to bring up any other stuff during office hours as well.
	Yeah?
	In general, is it easier to start from the expression you go out?
	It really depends on the expression.
	Yeah.
	The fact that JavaScript does it one way and Haskell does it another way is kind of indicative
	of there's no right answer.
	It's not that one of the two of them is smarter and better.
	It's that they're different approaches.
	Either one might be better.
	Okay.
	So what we have been talking about is lambda calculus's substitution model.
	Where we said we could have a function with a function application and we can beta reduce
	it to some other expression.
	In JavaScript, that above function looks something like this.
	And why we care about it is because we can do this beta reduction at compile time.
	That's not a runtime evaluation.
	That's a compile time simplification of your code.
	So that at runtime, we don't need to compute it.
	And if you're gonna do this over and over, then compile once, run ten times, it's highly
	effective to beta reduce.
	But why would you not want to do that?
	If we tried to do beta reduction on these slides are on Canvas, by the way, already.
	So if you do that and follow along, they are already up there.
	Why would you not want to do a beta reduction in a real language like JavaScript?
	Where we're trying to say set X equal to some parameter for all X in some scope.
	What can go wrong?
	Yeah.
	Yeah.
	In JavaScript, we can update the value of X.
	X might be something at the start of a function and change to be something else at the end
	of the function.
	We've been working with JavaScript that looks like this, but that's not actually all of
	JavaScript's power.
	We could say X equals X plus 1 on the second line of this function.
	And then if we've substituted everything, we're kind of, like, in a limbo land.
	It can also slow things down.
	We don't need to get into that.
	But to point out this idea of change and mutation in JavaScript, if we had a relatively simple
	function, let Y equal 1, Z equal 0, Z plus plus, log Z, what do we expect to be the output
	of console.log?
	1.
	1.
	Right?
	We've started Z as 0, we incremented Z, and then we output Z.
	If we did a beta reduction of all Z is equal to 0, then when we get to this log, we log
	0.
	So most languages support this idea of mutation.
	Variables are not static.
	They change.
	They're called variable for a reason.
	Pascal has a different idea and says variables aren't variable.
	They are static.
	And part of the reason for that is so that they can do more substitution.
	So what can we do about this?
	We're going to spend the next lecture and a half talking about how to translate from
	the kind of mathematician ivory tower of lambda calculus, not quite all the way down
	to the machine model, but talk about the environment model of JavaScript somewhere in between.
	Where we get some of the benefits of lambda calculus, but we aren't all the way in the
	nuts and bolts of things.
	It'll look like this.
	This is what we're going to kind of be covering.
	What does scope look like?
	How do first order functions yeah.
	First order functions to start.
	How do those work with scope?
	How do free variables play into this?
	And then finally, how do high order functions work with scope?
	So to start, what is a scope?
	What's the point of a scope?
	What do you use it for?
	You guys have a lot of answers.
	Someone who hasn't brought something up.
	I do appreciate it, just to be clear.
	It's not bad that you guys answer a lot of questions.
	What's the point of a scope?
	You guys use these all the time.
	When was the last time you wrote code?
	It's like yesterday.
	Right?
	There was a PA.
	You had to use a scope in the PA.
	Yeah?
	No, definitely.
	So to make variables easier to use, I think, is a pretty concise summary of what's the
	point of a scope.
	We want to encapsulate and hide these variables live here.
	It doesn't care about, like, these variables don't matter anywhere else.
	Don't use the same X that I've defined here in some other place.
	Yeah?
	PA is due next week.
	PA2 should be due this Sunday.
	Is that not what grade scope says?
	I'll fix that.
	It should be this Sunday.
	PA2 and 3 are due, like, this upcoming Sunday.
	Not yesterday.
	No.
	Oh, yeah.
	I guess I did just say...
	Yeah, no.
	Some of you might have been writing code.
	I don't know.
	Whatever.
	You guys should probably be writing more code than you are currently writing.
	That's definitely true.
	For probably 99 of you.
	But PA is due in six days or something like that.
	Yep.
	Don't worry if you didn't submit it.
	Okay.
	So scopes.
	The point of them is to encapsulate state specific to the area of code that we're working
	on.
	Right?
	If we're saying X here is equal to this thing, this is where I'm gonna use X with this value.
	Not elsewhere in, like, a different library.
	I don't want that other implementation of X.
	I want my version of X.
	So how are we gonna capture that?
	We are...
	We're not going here.
	But we are gonna be somewhere in the middle here, where we're talking about, like, what
	do we need to actually use a scope?
	If we wanted to track this idea of the environment of our program over time, we're gonna need
	some information.
	So going to the previous example, we're going to create environments, which I call activation
	records of whatever we are currently executing.
	When we are inside of one scope, we want information about that scope.
	It's doing X in this scope.
	And we're going to contain all of our variables in this environment.
	And then we're also going to contain some extra information.
	If you've taken kind of lower level classes, where you've done Spark or MIPS or X86 or
	whatever, you have to keep track of things like the stack pointer, the return address,
	the frame pointer.
	This is environmental information about what we're currently executing.
	So what we might do is, for the current snippet, we could have our environment pointer point
	to this area of memory, where we've said Y is equal to 1, Z is equal to 0.
	This is our state.
	It's our square brackets from lambda calculus.
	As opposed to the code, the expressions that we're going to execute.
	Depends on the setup.
	Okay.
	One minor piece of this that we kind of ignore after this one slide.
	But there's the canonical idea of R values and L values.
	R values are true expressions where we can treat them like lambda calculus.
	They're very mathematical.
	We can simplify as much as we want.
	There's no backing environment to them.
	And L values are pointers to R values.
	They're like the buckets that you learn about with variables.
	So L values point to R value information.
	And when we look at something like plus plus, when we say Z plus plus or plus plus Z, we
	can't plus plus an R value, because plus plus is mutating the state.
	So you can only plus plus an L value so that it can update itself.
	So in our thing over here, the left-hand side, the YZ, those are our L values that
	are pointing to R values on the right-hand side.
	We can plus plus Z. You can't plus plus 0.
	Because plus plus 0, it's like, what does that even mean?
	Maybe it returns 1.
	Maybe it doesn't.
	But it certainly doesn't update the number 0 to be 1.
	That would be really weird.
	If later, you then, like, use 0 and got 1.
	Goodness.
	OK.
	So that's L values, R values, whatever.
	When we want to execute console.log Z, we will go look at our environment and say, what
	context are we evaluating console.log Z in?
	Oh, sorry.
	We're looking at the Z plus plus first.
	When we execute Z plus plus, we say, what environment are we executing that in?
	Our environment is the little square.
	We go look up the value of Z. Z is 0.
	We increment it to 1.
	So we find our environment.
	We check to see if we're inside of the environment.
	And then we use the environment.
	When we log Z, the process is the same.
	We find what our current environment is, which is whatever our environment pointer
	points to.
	We look up the value of Z. What's the value of Z?
	What's the value of Z?
	1.
	1.
	Yeah.
	It's in the table right there.
	So we print out 1.
	This algorithm sounds a little slow.
	That's because it is.
	It's not very convenient to continually look up the environment pointer, check what my
	variables are.
	Is my variable there?
	If it's not, go find it somewhere else.
	That's partially because we're not in the machine model.
	We aren't talking about x86 or Spark.
	But it's also just a kind of necessary evil.
	You have to be able to find what is my environment.
	So we can come up with kind of, like, speedy hacks around it.
	But at the end of the day, we have to do this approach.
	Anytime we're executing code, we have to know what environment are we executing that code
	in.
	Because it's very different to log Z here than in a totally different program where
	you said Z is 100.
	Or Z is omega.
	Or, you know, whatever.
	Those mean different things depending on the environment.
	OK.
	That's the anatomy of a scope.
	Which is not, like, it's not crazy.
	It's not supposed to be something totally new.
	Scopes are scopes.
	Scopes store variables.
	Right?
	When do we create environments?
	When do we create scopes?
	Chat with someone next to you.
	When do we need to do these?
	A, B, A and B, or never?
	How many people vote A?
	Every time we create a new block scope.
	Or every time we enter a new block scope.
	How many people vote B?
	Every time we enter a new function scope.
	How many people vote A and B?
	All right.
	We got a majority there.
	Anybody say we don't need new environments?
	OK.
	Nobody's really...
	Oh, maybe we have a jokester.
	There are some worlds where you might have a language that doesn't create new environments.
	It's not unreasonable.
	And there was a version of JavaScript where you didn't have new block scopes.
	Or new scope on a block scope.
	Because we only really cared about function scope.
	Nowadays, it's A and B. Whenever you create a new block scope or a new function scope.
	Then we create a new environment.
	So the approach we're gonna take, and we're gonna spend a lot of time drawing these diagrams,
	and this is basically what the homework looks like, is we will have a function.
	We will call that function.
	And then we're going to keep track of the environment as we execute that code.
	And one of the main points of this chunk of class is so that you can look at this code
	and say...
	I know what that's gonna do.
	Here it's pretty obvious.
	It's factorial.
	We called it fact.
	That's not always the case.
	Sometimes you're presented with code that looks like...
	What the heck is this doing?
	Being able to trace through it and understand what state is looking like as you are tracing
	through it is extremely valuable.
	It saves you a lot of time.
	Rather than having to put a bunch of console.log inside of the code and then run it and run
	it.
	Or put a breakpoint and run it and run it.
	So we're finishing up with class now.
	We're gonna pick up on Wednesday diving into how can we track environment as we run JavaScript
	code.
	Feel free to drop by office hours.
	Otherwise, have a good week.
	Bye.
	Bye.
	Bye.
	Bye.
	Bye.
	Bye.
	Bye.
	Bye.

</p>
</body>
</html>